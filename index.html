<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Morphing Shapes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

<style>
    *, *::before, *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        font-family: "Inter", sans-serif;
        overflow: hidden;
        background: #040307; 
        background-image:
            radial-gradient(circle at 50% 35%, #1d1431 0%, transparent 65%),
            linear-gradient(180deg, #000000 0%, #070012 100%);
        color: #eee;
    }
    #container {
        position: fixed;
        inset: 0;
    }
    .vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 9;
        background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%);
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .instructions {
        position: fixed;
        left: 24px;
        bottom: 24px;
        transform: none;
        padding: 10px 20px;
        font-size: 12px;
        text-align: left;
        pointer-events: none;
        color: #d0b0ff;
        background: rgba(18, 15, 40, 0.25);
        border: 1px solid rgba(122, 70, 255, 0.28);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
    }

    .performance-panel {
        position: fixed;
        right: 24px;
        top: 24px;
        padding: 16px 20px;
        font-size: 11px;
        font-family: 'Courier New', monospace;
        pointer-events: none;
        color: #d0b0ff;
        background: rgba(18, 15, 40, 0.4);
        border: 1px solid rgba(122, 70, 255, 0.28);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
        min-width: 200px;
        line-height: 1.6;
    }

    .performance-panel .metric {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
    }

    .performance-panel .metric-label {
        color: #a0a0a0;
    }

    .performance-panel .metric-value {
        color: #d0b0ff;
        font-weight: 500;
    }

    .performance-panel .metric-value.good {
        color: #2af16b;
    }

    .performance-panel .metric-value.warning {
        color: #ffaa00;
    }

    .performance-panel .metric-value.bad {
        color: #ff4444;
    }

    .performance-panel .separator {
        height: 1px;
        background: rgba(122, 70, 255, 0.2);
        margin: 8px 0;
    }

    .performance-toggle {
        position: fixed;
        right: 24px;
        top: 24px;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: rgba(18, 15, 40, 0.6);
        border: 2px solid rgba(122, 70, 255, 0.5);
        color: #d0b0ff;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 11;
        backdrop-filter: blur(12px);
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
        transition: all 0.3s ease;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }

    .performance-toggle:hover {
        background: rgba(18, 15, 40, 0.8);
        border-color: rgba(122, 70, 255, 0.8);
        transform: scale(1.1);
    }

    .performance-toggle:active {
        transform: scale(0.95);
    }

    /* –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É —Ç–æ–ª—å–∫–æ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
    @media (min-width: 768px) {
        .performance-toggle {
            display: none;
        }
    }

    /* –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —Å–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É */
    @media (max-width: 767px) {
        .performance-panel {
            right: 12px;
            top: 80px;
            font-size: 10px;
            padding: 12px 16px;
            min-width: 160px;
        }
    }

</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<div id="container"></div>
<div class="vignette"></div>
<div class="instructions">Drag to explore</div>
<button class="performance-toggle" id="performanceToggle" aria-label="Toggle performance monitor">üìä</button>
<div class="performance-panel" id="performancePanel" style="display: none;">
    <div class="metric">
        <span class="metric-label">FPS:</span>
        <span class="metric-value" id="fps">--</span>
    </div>
    <div class="metric">
        <span class="metric-label">Frame Time:</span>
        <span class="metric-value" id="frameTime">--</span>
    </div>
    <div class="separator"></div>
    <div class="metric">
        <span class="metric-label">Particles:</span>
        <span class="metric-value" id="particleCount">--</span>
    </div>
    <div class="metric">
        <span class="metric-label">Background:</span>
        <span class="metric-value" id="bgParticleCount">--</span>
    </div>
    <div class="metric">
        <span class="metric-label">Total:</span>
        <span class="metric-value" id="totalParticles">--</span>
    </div>
    <div class="separator"></div>
    <div class="metric">
        <span class="metric-label">Draw Calls:</span>
        <span class="metric-value" id="drawCalls">--</span>
    </div>
    <div class="metric">
        <span class="metric-label">Triangles:</span>
        <span class="metric-value" id="triangles">--</span>
    </div>
    <div class="metric">
        <span class="metric-label">Points:</span>
        <span class="metric-value" id="points">--</span>
    </div>
    <div class="separator"></div>
    <div class="metric">
        <span class="metric-label">Memory (MB):</span>
        <span class="metric-value" id="memory">--</span>
    </div>
    <div class="metric">
        <span class="metric-label">Status:</span>
        <span class="metric-value" id="status">--</span>
    </div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

// ============================================================================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
// ============================================================================

// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü
const CONFIG = {
    particleCount: 39575,
    backgroundParticleCount: 5000,
    digitSizeMultiplier: 1.2,
    
    // –ü–æ–≤–æ—Ä–æ—Ç –º–æ–¥–µ–ª–∏ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö)
    modelRotation: {
        x: -(Math.PI / 2),
        y: 0,
        z: Math.PI
    },
    
    // –¶–≤–µ—Ç–∞ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (RGB 0-255, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é—Ç—Å—è –≤ 0-1)
    gradient: {
        topColor: { r: 42, g: 241, b: 107 },      // –ë–µ–ª—ã–π (–≤–µ—Ä—Ö)
        bottomColor: { r: 255, g: 255, b: 255 },    // #2AF16B (–Ω–∏–∑)
        intensity: 1.0,                             // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 - –Ω–µ—Ç –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞, 1.0 - –ø–æ–ª–Ω—ã–π)
        blendStart: 0.2,                            // –ù–∞—á–∞–ª–æ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 = –≤–µ—Ä—Ö, 1.0 = –Ω–∏–∑)
        blendEnd: 1.0                              // –ö–æ–Ω–µ—Ü –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 = –≤–µ—Ä—Ö, 1.0 = –Ω–∏–∑)
    },
    
    // –¶–≤–µ—Ç–∞ –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
    backgroundColors: {
        color0: { r: 255, g: 255, b: 255 },         // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –Ω—É–ª–µ–π
        color1: { r: 42, g: 241, b: 107 }          // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü
    },
    
    // –†–∞–∑–º–µ—Ä—ã —á–∞—Å—Ç–∏—Ü
    particleSizes: {
        size0: 1.0,                                 // –†–∞–∑–º–µ—Ä –Ω—É–ª–µ–π
        size1: 1.0                                 // –†–∞–∑–º–µ—Ä –µ–¥–∏–Ω–∏—Ü
    },
    
    // –û—Å–≤–µ—â–µ–Ω–∏–µ –∏ —Ç–µ–Ω–∏
    lighting: {
        shadowIntensity: 0.95,                      // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π (0.0 - –Ω–µ—Ç —Ç–µ–Ω–µ–π, 1.0 - –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ)
        lightDirection: { x: 0.3, y: 1.0, z: 0.5 }  // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ (–Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
    }
};

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ü–≤–µ—Ç–∞ –≤ Vector3 –¥–ª—è Three.js
const colorSettings = {
    gradientTop: new THREE.Vector3(
        CONFIG.gradient.topColor.r / 255,
        CONFIG.gradient.topColor.g / 255,
        CONFIG.gradient.topColor.b / 255
    ),
    gradientBottom: new THREE.Vector3(
        CONFIG.gradient.bottomColor.r / 255,
        CONFIG.gradient.bottomColor.g / 255,
        CONFIG.gradient.bottomColor.b / 255
    ),
    bgColor0: new THREE.Vector3(
        CONFIG.backgroundColors.color0.r / 255,
        CONFIG.backgroundColors.color0.g / 255,
        CONFIG.backgroundColors.color0.b / 255
    ),
    bgColor1: new THREE.Vector3(
        CONFIG.backgroundColors.color1.r / 255,
        CONFIG.backgroundColors.color1.g / 255,
        CONFIG.backgroundColors.color1.b / 255
    ),
    size0: CONFIG.particleSizes.size0,
    size1: CONFIG.particleSizes.size1,
    shadowIntensity: CONFIG.lighting.shadowIntensity
};

let scene, camera, renderer, controls;
let particles, backgroundParticles;
let clock = new THREE.Clock();
let digitTexture0, digitTexture1;

// ============================================================================
// –°–ò–°–¢–ï–ú–ê –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
// ============================================================================

const PerformanceMonitor = {
    enabled: false,
    fps: 0,
    frameTime: 0,
    frameCount: 0,
    lastTime: performance.now(),
    fpsHistory: [],
    maxHistoryLength: 60,
    
    init() {
        const panel = document.getElementById('performancePanel');
        const toggleBtn = document.getElementById('performanceToggle');
        
        // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –ø–∞–Ω–µ–ª–∏
        const togglePanel = () => {
            this.enabled = !this.enabled;
            panel.style.display = this.enabled ? 'block' : 'none';
            if (toggleBtn) {
                toggleBtn.style.opacity = this.enabled ? '0.7' : '1';
            }
        };
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ P (–¥–µ—Å–∫—Ç–æ–ø)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                togglePanel();
            }
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ (–º–æ–±–∏–ª—å–Ω—ã–µ)
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePanel();
            });
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ñ–ª–∏–∫—Ç —Å OrbitControls
            toggleBtn.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });
        }
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–æ–±–∏–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
            || (window.innerWidth <= 768);
        
        // –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É, –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–µ - —Ç–æ–ª—å–∫–æ –ø–æ –Ω–∞–∂–∞—Ç–∏—é P
        if (isMobile && toggleBtn) {
            toggleBtn.style.display = 'flex';
        }
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –≤ –∫–æ–Ω—Å–æ–ª–∏
        console.log('%cüìä Performance Monitor', 'color: #2af16b; font-size: 14px; font-weight: bold;');
        if (isMobile) {
            console.log('–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É üìä –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É –¥–ª—è –ø–æ–∫–∞–∑–∞/—Å–∫—Ä—ã—Ç–∏—è –ø–∞–Ω–µ–ª–∏');
        } else {
            console.log('–ù–∞–∂–º–∏—Ç–µ P –¥–ª—è –ø–æ–∫–∞–∑–∞/—Å–∫—Ä—ã—Ç–∏—è –ø–∞–Ω–µ–ª–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏');
        }
        console.log('–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PerformanceMonitor.getStats() –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
        console.log('–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PerformanceMonitor.getOptimizationTips() –¥–ª—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π');
        console.log('–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PerformanceMonitor.printOptimizationTips() –¥–ª—è –≤—ã–≤–æ–¥–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π');
        
        // –í—ã–≤–æ–¥–∏–º –Ω–∞—á–∞–ª—å–Ω—É—é –æ—Ü–µ–Ω–∫—É
        setTimeout(() => {
            this.printOptimizationTips();
            this.printProductionReadiness();
        }, 2000);
    },
    
    update() {
        if (!this.enabled) return;
        
        const now = performance.now();
        const delta = now - this.lastTime;
        this.frameCount++;
        
        if (delta >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / delta);
            this.frameTime = (delta / this.frameCount).toFixed(2);
            
            this.fpsHistory.push(this.fps);
            if (this.fpsHistory.length > this.maxHistoryLength) {
                this.fpsHistory.shift();
            }
            
            this.frameCount = 0;
            this.lastTime = now;
            
            this.updateUI();
        }
    },
    
    updateUI() {
        const fpsEl = document.getElementById('fps');
        const frameTimeEl = document.getElementById('frameTime');
        const particleCountEl = document.getElementById('particleCount');
        const bgParticleCountEl = document.getElementById('bgParticleCount');
        const totalParticlesEl = document.getElementById('totalParticles');
        const drawCallsEl = document.getElementById('drawCalls');
        const trianglesEl = document.getElementById('triangles');
        const pointsEl = document.getElementById('points');
        const memoryEl = document.getElementById('memory');
        const statusEl = document.getElementById('status');
        
        // FPS
        fpsEl.textContent = this.fps;
        fpsEl.className = 'metric-value ' + this.getFpsClass(this.fps);
        
        // Frame Time
        frameTimeEl.textContent = this.frameTime + ' ms';
        frameTimeEl.className = 'metric-value ' + this.getFrameTimeClass(parseFloat(this.frameTime));
        
        // Particle counts
        if (particles) {
            particleCountEl.textContent = CONFIG.particleCount.toLocaleString();
            bgParticleCountEl.textContent = CONFIG.backgroundParticleCount.toLocaleString();
            totalParticlesEl.textContent = (CONFIG.particleCount + CONFIG.backgroundParticleCount).toLocaleString();
        }
        
        // Renderer info
        if (renderer && renderer.info) {
            const info = renderer.info;
            drawCallsEl.textContent = info.render.calls || 'N/A';
            trianglesEl.textContent = (info.render.triangles || 0).toLocaleString();
            pointsEl.textContent = (info.render.points || 0).toLocaleString();
        }
        
        // Memory (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
        if (performance.memory) {
            const memoryMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
            memoryEl.textContent = memoryMB;
        } else {
            memoryEl.textContent = 'N/A';
        }
        
        // Status
        const status = this.getStatus();
        statusEl.textContent = status.text;
        statusEl.className = 'metric-value ' + status.class;
    },
    
    getFpsClass(fps) {
        if (fps >= 55) return 'good';
        if (fps >= 30) return 'warning';
        return 'bad';
    },
    
    getFrameTimeClass(frameTime) {
        if (frameTime <= 18) return 'good';  // ~60 FPS
        if (frameTime <= 33) return 'warning'; // ~30 FPS
        return 'bad';
    },
    
    getStatus() {
        const avgFps = this.fpsHistory.length > 0 
            ? this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length 
            : this.fps;
        
        if (avgFps >= 55) {
            return { text: '–û—Ç–ª–∏—á–Ω–æ', class: 'good' };
        } else if (avgFps >= 30) {
            return { text: '–ù–æ—Ä–º–∞–ª—å–Ω–æ', class: 'warning' };
        } else {
            return { text: '–¢—Ä–µ–±—É–µ—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏', class: 'bad' };
        }
    },
    
    getStats() {
        const avgFps = this.fpsHistory.length > 0 
            ? this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length 
            : this.fps;
        const minFps = this.fpsHistory.length > 0 ? Math.min(...this.fpsHistory) : this.fps;
        const maxFps = this.fpsHistory.length > 0 ? Math.max(...this.fpsHistory) : this.fps;
        
        return {
            currentFps: this.fps,
            averageFps: Math.round(avgFps),
            minFps,
            maxFps,
            frameTime: parseFloat(this.frameTime),
            particleCount: CONFIG.particleCount,
            backgroundParticleCount: CONFIG.backgroundParticleCount,
            totalParticles: CONFIG.particleCount + CONFIG.backgroundParticleCount
        };
    },
    
    getOptimizationTips() {
        const stats = this.getStats();
        const tips = [];
        
        if (stats.averageFps < 30) {
            tips.push('‚ö†Ô∏è –ù–∏–∑–∫–∏–π FPS. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:');
            tips.push('  ‚Ä¢ –£–º–µ–Ω—å—à–∏—Ç–µ CONFIG.particleCount (—Ç–µ–∫—É—â–µ–µ: ' + CONFIG.particleCount + ')');
            tips.push('  ‚Ä¢ –£–º–µ–Ω—å—à–∏—Ç–µ CONFIG.backgroundParticleCount (—Ç–µ–∫—É—â–µ–µ: ' + CONFIG.backgroundParticleCount + ')');
            tips.push('  ‚Ä¢ –£–º–µ–Ω—å—à–∏—Ç–µ CONFIG.digitSizeMultiplier –¥–ª—è –º–µ–Ω—å—à–∏—Ö —á–∞—Å—Ç–∏—Ü');
            tips.push('  ‚Ä¢ –û—Ç–∫–ª—é—á–∏—Ç–µ antialiasing –≤ renderer');
        }
        
        if (stats.totalParticles > 50000) {
            tips.push('‚ö†Ô∏è –ë–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü: ' + stats.totalParticles);
            tips.push('  ‚Ä¢ –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ LOD (Level of Detail) —Å–∏—Å—Ç–µ–º—É');
            tips.push('  ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ frustum culling');
        }
        
        if (renderer && renderer.info && renderer.info.render.calls > 10) {
            tips.push('‚ö†Ô∏è –ú–Ω–æ–≥–æ draw calls: ' + renderer.info.render.calls);
            tips.push('  ‚Ä¢ –û–±—ä–µ–¥–∏–Ω–∏—Ç–µ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ');
        }
        
        if (tips.length === 0) {
            tips.push('‚úÖ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –Ω–æ—Ä–º–µ!');
        }
        
        return tips;
    },
    
    printOptimizationTips() {
        const tips = this.getOptimizationTips();
        console.log('%cüí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:', 'color: #ffaa00; font-size: 12px; font-weight: bold;');
        tips.forEach(tip => console.log(tip));
    },
    
    printProductionReadiness() {
        const stats = this.getStats();
        const issues = [];
        const warnings = [];
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º FPS
        if (stats.averageFps < 30) {
            issues.push('FPS –Ω–∏–∂–µ 30 (' + stats.averageFps + ')');
        } else if (stats.averageFps < 55) {
            warnings.push('FPS –Ω–∏–∂–µ 55 (' + stats.averageFps + ')');
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü
        if (stats.totalParticles > 100000) {
            issues.push('–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —á–∞—Å—Ç–∏—Ü: ' + stats.totalParticles);
        } else if (stats.totalParticles > 50000) {
            warnings.push('–ú–Ω–æ–≥–æ —á–∞—Å—Ç–∏—Ü: ' + stats.totalParticles + ' (–º–æ–∂–µ—Ç –±—ã—Ç—å —Ç—è–∂–µ–ª–æ –Ω–∞ —Å–ª–∞–±—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö)');
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º frame time
        if (stats.frameTime > 33) {
            issues.push('Frame time —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–∏–π: ' + stats.frameTime + 'ms');
        } else if (stats.frameTime > 18) {
            warnings.push('Frame time –≤—ã—à–µ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ: ' + stats.frameTime + 'ms');
        }
        
        console.log('%cüöÄ –û—Ü–µ–Ω–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É:', 'color: #2af16b; font-size: 12px; font-weight: bold;');
        
        if (issues.length === 0 && warnings.length === 0) {
            console.log('%c‚úÖ –ì–æ—Ç–æ–≤–æ –∫ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É!', 'color: #2af16b; font-weight: bold;');
            console.log('  ‚Ä¢ FPS: ' + stats.averageFps + ' (–æ—Ç–ª–∏—á–Ω–æ)');
            console.log('  ‚Ä¢ –ß–∞—Å—Ç–∏—Ü: ' + stats.totalParticles);
            console.log('  ‚Ä¢ Frame time: ' + stats.frameTime + 'ms');
        } else {
            if (issues.length > 0) {
                console.log('%c‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:', 'color: #ff4444; font-weight: bold;');
                issues.forEach(issue => console.log('  ‚Ä¢ ' + issue));
            }
            if (warnings.length > 0) {
                console.log('%c‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è:', 'color: #ffaa00; font-weight: bold;');
                warnings.forEach(warning => console.log('  ‚Ä¢ ' + warning));
            }
            console.log('%cüí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PerformanceMonitor.getOptimizationTips() –¥–ª—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π', 'color: #d0b0ff;');
        }
        
        return {
            ready: issues.length === 0,
            issues,
            warnings,
            stats
        };
    }
};

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏
window.PerformanceMonitor = PerformanceMonitor;

function normalise(points, size) {
    if (points.length === 0) return [];
    const box = new THREE.Box3().setFromPoints(points);
    const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1;
    const centre = box.getCenter(new THREE.Vector3());
    return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim));
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤–µ—Ä—à–∏–Ω –∏ –Ω–æ—Ä–º–∞–ª–µ–π –∏–∑ 3D –º–æ–¥–µ–ª–∏
async function loadModelPattern(modelPath, targetCount) {
    return new Promise((resolve, reject) => {
        const loader = new GLTFLoader();
        loader.load(
            modelPath,
            (gltf) => {
                const points = [];
                const normals = [];
                
                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –≤—Å–µ –º–µ—à–∏ –≤ –º–æ–¥–µ–ª–∏
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        const positionAttribute = geometry.attributes.position;
                        const normalAttribute = geometry.attributes.normal;
                        
                        // –ü–æ–ª—É—á–∞–µ–º –º–∏—Ä–æ–≤—É—é –º–∞—Ç—Ä–∏—Ü—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                        child.updateMatrixWorld();
                        const worldMatrix = child.matrixWorld;
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(worldMatrix);
                        
                        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã –∏ –Ω–æ—Ä–º–∞–ª–∏
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                            vertex.applyMatrix4(worldMatrix);
                            points.push(vertex);
                            
                            if (normalAttribute) {
                                const normal = new THREE.Vector3().fromBufferAttribute(normalAttribute, i);
                                normal.applyMatrix3(normalMatrix).normalize();
                                normals.push(normal);
                            } else {
                                normals.push(new THREE.Vector3(0, 1, 0));
                            }
                        }
                    }
                });
                
                // –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –≤–µ—Ä—à–∏–Ω –≤ –∫–æ–Ω—Å–æ–ª—å
                const uniqueVertexCount = points.length;
                console.log(`üìä –ú–æ–¥–µ–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç ${uniqueVertexCount} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω`);
                console.log(`üéØ –ó–∞–ø—Ä–æ—à–µ–Ω–æ —á–∞—Å—Ç–∏—Ü: ${targetCount}`);
                
                if (uniqueVertexCount < targetCount) {
                    console.warn(`‚ö†Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü (${targetCount}) –±–æ–ª—å—à–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–µ—Ä—à–∏–Ω –º–æ–¥–µ–ª–∏ (${uniqueVertexCount}). –ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –¥—É–±–ª–∏–∫–∞—Ç—ã.`);
                    console.log(`üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å CONFIG.particleCount <= ${uniqueVertexCount} –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è`);
                } else {
                    console.log(`‚úÖ –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–µ—Ä—à–∏–Ω –¥–ª—è ${targetCount} —á–∞—Å—Ç–∏—Ü`);
                }
                
                // –†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –≤–µ—Ä—à–∏–Ω –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã
                const resultPoints = [];
                const resultNormals = [];
                if (points.length === 0) {
                    reject(new Error('–ú–æ–¥–µ–ª—å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ—Ä—à–∏–Ω'));
                    return;
                }
                
                if (points.length >= targetCount) {
                    const step = points.length / targetCount;
                    for (let i = 0; i < targetCount; i++) {
                        const idx = Math.floor(i * step);
                        resultPoints.push(points[idx].clone());
                        resultNormals.push(normals[idx].clone());
                    }
                } else {
                    resultPoints.push(...points.map(p => p.clone()));
                    resultNormals.push(...normals.map(n => n.clone()));
                    
                    while (resultPoints.length < targetCount) {
                        const idx = resultPoints.length % points.length;
                        resultPoints.push(points[idx].clone());
                        resultNormals.push(normals[idx].clone());
                    }
                }
                
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ–∑–∏—Ü–∏–∏
                const normalizedPoints = normalise(resultPoints, 50);
                
                resolve({ points: normalizedPoints, normals: resultNormals });
            },
            undefined,
            (error) => {
                reject(error);
            }
        );
    });
}

function createTextTexture(text, size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size * 0.8}px Inter, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // –ï—Å–ª–∏ —ç—Ç–æ "1", –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤ –∏ –æ—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º
    if (text === '1') {
        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI);
        ctx.scale(-1, 1); // –û—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        ctx.translate(-size / 2, -size / 2);
    }
    
    ctx.fillText(text, size / 2, size / 2);
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

// –ü—Ä–æ—Å—Ç–∞—è —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è —Ü–∏—Ñ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏
function hashPosition(x, y, z) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    const hash = ((x * 73856093) ^ (y * 19349663) ^ (z * 83492791)) >>> 0;
    return hash % 2; // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0 –∏–ª–∏ 1
}

function makeParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const shadowFactor = new Float32Array(count);
    const heightFactor = new Float32Array(count); // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    
    for (let i = 0; i < count; i++) {
        size[i] = 2.0;
        digit[i] = 0.0;
        shadowFactor[i] = 1.0;
        heightFactor[i] = 0.5; // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ –≤ applyPattern
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("shadowFactor", new THREE.BufferAttribute(shadowFactor, 1));
    geo.setAttribute("heightFactor", new THREE.BufferAttribute(heightFactor, 1));
    
    const sizeMult = CONFIG.digitSizeMultiplier.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            gradientTop: { value: colorSettings.gradientTop },
            gradientBottom: { value: colorSettings.gradientBottom },
            gradientIntensity: { value: CONFIG.gradient.intensity },
            gradientBlendStart: { value: CONFIG.gradient.blendStart },
            gradientBlendEnd: { value: CONFIG.gradient.blendEnd },
            size0: { value: colorSettings.size0 },
            size1: { value: colorSettings.size1 },
            shadowIntensity: { value: colorSettings.shadowIntensity }
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            attribute float shadowFactor;
            attribute float heightFactor;
            uniform float size0;
            uniform float size1;
            varying float vDigit;
            varying float vShadowFactor;
            varying float vHeightFactor;
            void main() {
                vDigit = digit;
                vShadowFactor = shadowFactor;
                vHeightFactor = heightFactor;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                float finalSize = vDigit < 0.5 ? size0 : size1;
                gl_PointSize = finalSize * ${sizeMult} * (400.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 gradientTop;
            uniform vec3 gradientBottom;
            uniform float gradientIntensity;
            uniform float gradientBlendStart;
            uniform float gradientBlendEnd;
            uniform float shadowIntensity;
            varying float vDigit;
            varying float vShadowFactor;
            varying float vHeightFactor;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã—Å–æ—Ç—ã
                // vHeightFactor: 0.0 = –≤–µ—Ä—Ö (–±–µ–ª—ã–π), 1.0 = –Ω–∏–∑ (#2AF16B)
                float gradientT = clamp((vHeightFactor - gradientBlendStart) / (gradientBlendEnd - gradientBlendStart), 0.0, 1.0);
                vec3 gradientColor = mix(gradientTop, gradientBottom, gradientT);
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
                vec3 baseColor = mix(gradientTop, gradientColor, gradientIntensity);
                
                // –¢–µ–Ω–∏ —á–µ—Ä–µ–∑ opacity
                float finalOpacity = texColor.a * vShadowFactor;
                
                gl_FragColor = vec4(baseColor, finalOpacity);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });
    return new THREE.Points(geo, mat);
}

// –°–æ–∑–¥–∞–µ—Ç —Ñ–æ–Ω–æ–≤—ã–µ —á–∞—Å—Ç–∏—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ—Ç–∞—é—Ç –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
function createBackgroundParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const velocity = new Float32Array(count * 3);
    const radius = new Float32Array(count);
    
    const R = 120; // –†–∞–¥–∏—É—Å —Å—Ñ–µ—Ä—ã –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏

    for (let i = 0; i < count; i++) {
        // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å—Ñ–µ—Ä–µ
        const Œ∏ = Math.random() * 2 * Math.PI;
        const œÜ = Math.acos(2 * Math.random() - 1);
        const r = R + (Math.random() - 0.5) * 40;
        
        pos[i * 3] = r * Math.sin(œÜ) * Math.cos(Œ∏);
        pos[i * 3 + 1] = r * Math.sin(œÜ) * Math.sin(Œ∏);
        pos[i * 3 + 2] = r * Math.cos(œÜ);
        
        // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        velocity[i * 3] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        radius[i] = r;
        size[i] = 1.0 + Math.random() * 0.5;
        digit[i] = Math.random() < 0.5 ? 0.0 : 1.0;
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("velocity", new THREE.BufferAttribute(velocity, 3));
    geo.setAttribute("radius", new THREE.BufferAttribute(radius, 1));
    
    const sizeMult = CONFIG.digitSizeMultiplier.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            bgColor0: { value: colorSettings.bgColor0 },
            bgColor1: { value: colorSettings.bgColor1 }
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            varying float vDigit;
            void main() {
                vDigit = digit;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * ${sizeMult} * (300.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 bgColor0;
            uniform vec3 bgColor1;
            varying float vDigit;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–∏—Ñ—Ä—ã
                vec3 baseColor = vDigit < 0.5 ? bgColor0 : bgColor1;
                
                gl_FragColor = vec4(baseColor, texColor.a * 0.7);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });

    const points = new THREE.Points(geo, mat);
    points.userData.velocity = velocity;
    points.userData.radius = radius;
    return points;
}


function init() {
    digitTexture0 = createTextTexture('0', 256);
    digitTexture1 = createTextTexture('1', 256);
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050203, .012);

    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 2500);
    camera.position.set(0, 0, 80);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.info.autoReset = false; // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ—Å–±—Ä–æ—Å –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    document.getElementById("container").appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 20;
    controls.maxDistance = 200;
    controls.target.set(0, 0, 0);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    particles = makeParticles(CONFIG.particleCount);
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    particles.material.uniforms.gradientTop.value = colorSettings.gradientTop;
    particles.material.uniforms.gradientBottom.value = colorSettings.gradientBottom;
    particles.material.uniforms.gradientIntensity.value = CONFIG.gradient.intensity;
    particles.material.uniforms.gradientBlendStart.value = CONFIG.gradient.blendStart;
    particles.material.uniforms.gradientBlendEnd.value = CONFIG.gradient.blendEnd;
    particles.material.uniforms.size0.value = colorSettings.size0;
    particles.material.uniforms.size1.value = colorSettings.size1;
    particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
    
    scene.add(particles);
    
    // –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –ª–µ—Ç–∞—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    backgroundParticles = createBackgroundParticles(CONFIG.backgroundParticleCount);
    backgroundParticles.material.uniforms.bgColor0.value = colorSettings.bgColor0;
    backgroundParticles.material.uniforms.bgColor1.value = colorSettings.bgColor1;
    scene.add(backgroundParticles);
    
    // –î–µ–ª–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    window.updateColors = () => {
        // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
        colorSettings.gradientTop.set(
            CONFIG.gradient.topColor.r / 255,
            CONFIG.gradient.topColor.g / 255,
            CONFIG.gradient.topColor.b / 255
        );
        colorSettings.gradientBottom.set(
            CONFIG.gradient.bottomColor.r / 255,
            CONFIG.gradient.bottomColor.g / 255,
            CONFIG.gradient.bottomColor.b / 255
        );
        
        particles.material.uniforms.gradientTop.value.copy(colorSettings.gradientTop);
        particles.material.uniforms.gradientBottom.value.copy(colorSettings.gradientBottom);
        particles.material.uniforms.gradientIntensity.value = CONFIG.gradient.intensity;
        particles.material.uniforms.gradientBlendStart.value = CONFIG.gradient.blendStart;
        particles.material.uniforms.gradientBlendEnd.value = CONFIG.gradient.blendEnd;
        particles.material.uniforms.size0.value = colorSettings.size0;
        particles.material.uniforms.size1.value = colorSettings.size1;
        particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
        colorSettings.bgColor0.set(
            CONFIG.backgroundColors.color0.r / 255,
            CONFIG.backgroundColors.color0.g / 255,
            CONFIG.backgroundColors.color0.b / 255
        );
        colorSettings.bgColor1.set(
            CONFIG.backgroundColors.color1.r / 255,
            CONFIG.backgroundColors.color1.g / 255,
            CONFIG.backgroundColors.color1.b / 255
        );
        
        if (backgroundParticles) {
            backgroundParticles.material.uniforms.bgColor0.value.copy(colorSettings.bgColor0);
            backgroundParticles.material.uniforms.bgColor1.value.copy(colorSettings.bgColor1);
        }
    };
    window.CONFIG = CONFIG;
    window.colorSettings = colorSettings;

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å –º–æ–∑–≥–∞
    loadModelPattern('assets/brain6/scene.gltf', CONFIG.particleCount)
        .then((data) => {
            applyPattern(data.points, data.normals);
        })
        .catch((error) => {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
        });

    addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    PerformanceMonitor.init();
}

// –ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ç–æ—á–∫–∏ –º–æ–¥–µ–ª–∏ –∫ —á–∞—Å—Ç–∏—Ü–∞–º
// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ—Ä–º–∞–ª–∏ –∏–∑ –º–æ–¥–µ–ª–∏ –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è –∏–∑–≤–∏–ª–∏–Ω
function applyPattern(pts, normals){
    if (!pts || pts.length === 0) return;
    const particleArr = particles.geometry.attributes.position.array;
    const digitArr = particles.geometry.attributes.digit.array;
    const shadowFactorArr = particles.geometry.attributes.shadowFactor.array;
    const heightFactorArr = particles.geometry.attributes.heightFactor.array;
    
    // –°–æ–∑–¥–∞–µ–º –º–∞—Ç—Ä–∏—Ü—ã –ø–æ–≤–æ—Ä–æ—Ç–∞
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationFromEuler(new THREE.Euler(
        CONFIG.modelRotation.x,
        CONFIG.modelRotation.y,
        CONFIG.modelRotation.z,
        'XYZ'
    ));
    const normalRotationMatrix = new THREE.Matrix3().getNormalMatrix(rotationMatrix);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –∫ —Ç–æ—á–∫–∞–º –∏ –Ω–æ—Ä–º–∞–ª—è–º
    const rotatedPts = [];
    const rotatedNormals = [];
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const n = normals[i];
        if (!p) {
            rotatedPts.push(null);
            rotatedNormals.push(null);
            continue;
        }
        rotatedPts.push(p.clone().applyMatrix4(rotationMatrix));
        rotatedNormals.push(n ? n.clone().applyMatrix3(normalRotationMatrix).normalize() : new THREE.Vector3(0, 1, 0));
    }
    
    // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –º–æ–¥–µ–ª–∏ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    let minY = Infinity, maxY = -Infinity;
    for (let i = 0; i < rotatedPts.length; i++) {
        if (rotatedPts[i]) {
            minY = Math.min(minY, rotatedPts[i].y);
            maxY = Math.max(maxY, rotatedPts[i].y);
        }
    }
    const heightRange = maxY - minY || 1.0;
    
    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞
    const lightDir = new THREE.Vector3(
        CONFIG.lighting.lightDirection.x,
        CONFIG.lighting.lightDirection.y,
        CONFIG.lighting.lightDirection.z
    ).normalize();
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Ç–æ—á–∫–∏
    for (let j = 0; j < CONFIG.particleCount; j++) {
        const idx = j * 3;
        const p = rotatedPts[j];
        const n = rotatedNormals[j];
        if (!p) continue;
        
        particleArr[idx] = p.x;
        particleArr[idx + 1] = p.y;
        particleArr[idx + 2] = p.z;
        
        digitArr[j] = hashPosition(p.x, p.y, p.z);
        
        // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –≤—ã—Å–æ—Ç—É –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 = –≤–µ—Ä—Ö, 1.0 = –Ω–∏–∑)
        const normalizedHeight = heightRange > 0 ? (p.y - minY) / heightRange : 0.5;
        heightFactorArr[j] = normalizedHeight;
        
        // –û—Å–≤–µ—â–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ—Ä–º–∞–ª–µ–π (Lambertian)
        const NdotL = n.dot(lightDir);
        const halfLambert = NdotL * 0.5 + 0.5;
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π
        const ambient = 1.0 - colorSettings.shadowIntensity;
        let shadowFactor = ambient + halfLambert * colorSettings.shadowIntensity;
        shadowFactor = Math.max(0.05, Math.min(1.0, shadowFactor));
        
        shadowFactorArr[j] = shadowFactor;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.digit.needsUpdate = true;
    particles.geometry.attributes.shadowFactor.needsUpdate = true;
    particles.geometry.attributes.heightFactor.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ –¥–ª—è –Ω–æ–≤–æ–≥–æ –∫–∞–¥—Ä–∞
    if (renderer && renderer.info) {
        renderer.info.reset();
    }

    controls.update();

    // –ê–Ω–∏–º–∞—Ü–∏—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü - –ø–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
    if (backgroundParticles) {
        const posArr = backgroundParticles.geometry.attributes.position.array;
        const velArr = backgroundParticles.userData.velocity;
        const radArr = backgroundParticles.userData.radius;
        
        for (let i = 0; i < CONFIG.backgroundParticleCount; i++) {
            const i3 = i * 3;
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            posArr[i3] += velArr[i3] * dt * 10;
            posArr[i3 + 1] += velArr[i3 + 1] * dt * 10;
            posArr[i3 + 2] += velArr[i3 + 2] * dt * 10;
            
            // –£–¥–µ—Ä–∂–∏–≤–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Å—Ñ–µ—Ä—ã
            const dist = Math.sqrt(posArr[i3]**2 + posArr[i3+1]**2 + posArr[i3+2]**2);
            const maxDist = radArr[i] * 1.3;
            if (dist > maxDist || dist < radArr[i] * 0.7) {
                const scale = (dist > maxDist ? radArr[i] * 0.7 : maxDist) / dist;
                posArr[i3] *= scale;
                posArr[i3 + 1] *= scale;
                posArr[i3 + 2] *= scale;
            }
        }
        backgroundParticles.geometry.attributes.position.needsUpdate = true;
    }

    renderer.render(scene, camera);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    PerformanceMonitor.update();
}

init();
animate();
</script>