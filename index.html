<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Morphing Shapes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

<style>
    *, *::before, *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        font-family: "Inter", sans-serif;
        overflow: hidden;
        background: #040307; 
        background-image:
            radial-gradient(circle at 50% 35%, #1d1431 0%, transparent 65%),
            linear-gradient(180deg, #000000 0%, #070012 100%);
        color: #eee;
    }
    #container {
        position: fixed;
        inset: 0;
    }
    .vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 9;
        background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%);
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .instructions {
        position: fixed;
        left: 24px;
        bottom: 24px;
        transform: none;
        padding: 10px 20px;
        font-size: 12px;
        text-align: left;
        pointer-events: none;
        color: #d0b0ff;
        background: rgba(18, 15, 40, 0.25);
        border: 1px solid rgba(122, 70, 255, 0.28);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
    }

</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<div id="container"></div>
<div class="vignette"></div>
<div class="instructions">Drag to explore</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

// ============================================================================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
// ============================================================================

// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü
const CONFIG = {
    particleCount: 39575,
    backgroundParticleCount: 5000,
    digitSizeMultiplier: 1.2,
    
    // –ü–æ–≤–æ—Ä–æ—Ç –º–æ–¥–µ–ª–∏ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö)
    modelRotation: {
        x: -(Math.PI / 2),
        y: 0,
        z: Math.PI
    },
    
    // –¶–≤–µ—Ç–∞ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (RGB 0-255, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é—Ç—Å—è –≤ 0-1)
    gradient: {
        topColor: { r: 42, g: 241, b: 107 },      // –ë–µ–ª—ã–π (–≤–µ—Ä—Ö)
        bottomColor: { r: 255, g: 255, b: 255 },    // #2AF16B (–Ω–∏–∑)
        intensity: 1.0,                             // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 - –Ω–µ—Ç –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞, 1.0 - –ø–æ–ª–Ω—ã–π)
        blendStart: 0.2,                            // –ù–∞—á–∞–ª–æ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 = –≤–µ—Ä—Ö, 1.0 = –Ω–∏–∑)
        blendEnd: 1.0                              // –ö–æ–Ω–µ—Ü –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 = –≤–µ—Ä—Ö, 1.0 = –Ω–∏–∑)
    },
    
    // –¶–≤–µ—Ç–∞ –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
    backgroundColors: {
        color0: { r: 255, g: 255, b: 255 },         // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –Ω—É–ª–µ–π
        color1: { r: 42, g: 241, b: 107 }          // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü
    },
    
    // –†–∞–∑–º–µ—Ä—ã —á–∞—Å—Ç–∏—Ü
    particleSizes: {
        size0: 1.0,                                 // –†–∞–∑–º–µ—Ä –Ω—É–ª–µ–π
        size1: 1.0                                 // –†–∞–∑–º–µ—Ä –µ–¥–∏–Ω–∏—Ü
    },
    
    // –û—Å–≤–µ—â–µ–Ω–∏–µ –∏ —Ç–µ–Ω–∏
    lighting: {
        shadowIntensity: 0.95,                      // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π (0.0 - –Ω–µ—Ç —Ç–µ–Ω–µ–π, 1.0 - –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ)
        lightDirection: { x: 0.3, y: 1.0, z: 0.5 }  // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ (–Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
    }
};

// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ü–≤–µ—Ç–∞ –≤ Vector3 –¥–ª—è Three.js
const colorSettings = {
    gradientTop: new THREE.Vector3(
        CONFIG.gradient.topColor.r / 255,
        CONFIG.gradient.topColor.g / 255,
        CONFIG.gradient.topColor.b / 255
    ),
    gradientBottom: new THREE.Vector3(
        CONFIG.gradient.bottomColor.r / 255,
        CONFIG.gradient.bottomColor.g / 255,
        CONFIG.gradient.bottomColor.b / 255
    ),
    bgColor0: new THREE.Vector3(
        CONFIG.backgroundColors.color0.r / 255,
        CONFIG.backgroundColors.color0.g / 255,
        CONFIG.backgroundColors.color0.b / 255
    ),
    bgColor1: new THREE.Vector3(
        CONFIG.backgroundColors.color1.r / 255,
        CONFIG.backgroundColors.color1.g / 255,
        CONFIG.backgroundColors.color1.b / 255
    ),
    size0: CONFIG.particleSizes.size0,
    size1: CONFIG.particleSizes.size1,
    shadowIntensity: CONFIG.lighting.shadowIntensity
};

let scene, camera, renderer, controls;
let particles, backgroundParticles;
let clock = new THREE.Clock();
let digitTexture0, digitTexture1;

function normalise(points, size) {
    if (points.length === 0) return [];
    const box = new THREE.Box3().setFromPoints(points);
    const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1;
    const centre = box.getCenter(new THREE.Vector3());
    return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim));
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤–µ—Ä—à–∏–Ω –∏ –Ω–æ—Ä–º–∞–ª–µ–π –∏–∑ 3D –º–æ–¥–µ–ª–∏
async function loadModelPattern(modelPath, targetCount) {
    return new Promise((resolve, reject) => {
        const loader = new GLTFLoader();
        loader.load(
            modelPath,
            (gltf) => {
                const points = [];
                const normals = [];
                
                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –≤—Å–µ –º–µ—à–∏ –≤ –º–æ–¥–µ–ª–∏
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        const positionAttribute = geometry.attributes.position;
                        const normalAttribute = geometry.attributes.normal;
                        
                        // –ü–æ–ª—É—á–∞–µ–º –º–∏—Ä–æ–≤—É—é –º–∞—Ç—Ä–∏—Ü—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                        child.updateMatrixWorld();
                        const worldMatrix = child.matrixWorld;
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(worldMatrix);
                        
                        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã –∏ –Ω–æ—Ä–º–∞–ª–∏
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                            vertex.applyMatrix4(worldMatrix);
                            points.push(vertex);
                            
                            if (normalAttribute) {
                                const normal = new THREE.Vector3().fromBufferAttribute(normalAttribute, i);
                                normal.applyMatrix3(normalMatrix).normalize();
                                normals.push(normal);
                            } else {
                                normals.push(new THREE.Vector3(0, 1, 0));
                            }
                        }
                    }
                });
                
                // –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –≤–µ—Ä—à–∏–Ω –≤ –∫–æ–Ω—Å–æ–ª—å
                const uniqueVertexCount = points.length;
                console.log(`üìä –ú–æ–¥–µ–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç ${uniqueVertexCount} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω`);
                console.log(`üéØ –ó–∞–ø—Ä–æ—à–µ–Ω–æ —á–∞—Å—Ç–∏—Ü: ${targetCount}`);
                
                if (uniqueVertexCount < targetCount) {
                    console.warn(`‚ö†Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü (${targetCount}) –±–æ–ª—å—à–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–µ—Ä—à–∏–Ω –º–æ–¥–µ–ª–∏ (${uniqueVertexCount}). –ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –¥—É–±–ª–∏–∫–∞—Ç—ã.`);
                    console.log(`üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å CONFIG.particleCount <= ${uniqueVertexCount} –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è`);
                } else {
                    console.log(`‚úÖ –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–µ—Ä—à–∏–Ω –¥–ª—è ${targetCount} —á–∞—Å—Ç–∏—Ü`);
                }
                
                // –†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –≤–µ—Ä—à–∏–Ω –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã
                const resultPoints = [];
                const resultNormals = [];
                if (points.length === 0) {
                    reject(new Error('–ú–æ–¥–µ–ª—å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ—Ä—à–∏–Ω'));
                    return;
                }
                
                if (points.length >= targetCount) {
                    const step = points.length / targetCount;
                    for (let i = 0; i < targetCount; i++) {
                        const idx = Math.floor(i * step);
                        resultPoints.push(points[idx].clone());
                        resultNormals.push(normals[idx].clone());
                    }
                } else {
                    resultPoints.push(...points.map(p => p.clone()));
                    resultNormals.push(...normals.map(n => n.clone()));
                    
                    while (resultPoints.length < targetCount) {
                        const idx = resultPoints.length % points.length;
                        resultPoints.push(points[idx].clone());
                        resultNormals.push(normals[idx].clone());
                    }
                }
                
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ–∑–∏—Ü–∏–∏
                const normalizedPoints = normalise(resultPoints, 50);
                
                resolve({ points: normalizedPoints, normals: resultNormals });
            },
            undefined,
            (error) => {
                reject(error);
            }
        );
    });
}

function createTextTexture(text, size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size * 0.8}px Inter, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // –ï—Å–ª–∏ —ç—Ç–æ "1", –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤ –∏ –æ—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º
    if (text === '1') {
        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI);
        ctx.scale(-1, 1); // –û—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        ctx.translate(-size / 2, -size / 2);
    }
    
    ctx.fillText(text, size / 2, size / 2);
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

// –ü—Ä–æ—Å—Ç–∞—è —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è —Ü–∏—Ñ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏
function hashPosition(x, y, z) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    const hash = ((x * 73856093) ^ (y * 19349663) ^ (z * 83492791)) >>> 0;
    return hash % 2; // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0 –∏–ª–∏ 1
}

function makeParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const shadowFactor = new Float32Array(count);
    const heightFactor = new Float32Array(count); // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    
    for (let i = 0; i < count; i++) {
        size[i] = 2.0;
        digit[i] = 0.0;
        shadowFactor[i] = 1.0;
        heightFactor[i] = 0.5; // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ –≤ applyPattern
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("shadowFactor", new THREE.BufferAttribute(shadowFactor, 1));
    geo.setAttribute("heightFactor", new THREE.BufferAttribute(heightFactor, 1));
    
    const sizeMult = CONFIG.digitSizeMultiplier.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            gradientTop: { value: colorSettings.gradientTop },
            gradientBottom: { value: colorSettings.gradientBottom },
            gradientIntensity: { value: CONFIG.gradient.intensity },
            gradientBlendStart: { value: CONFIG.gradient.blendStart },
            gradientBlendEnd: { value: CONFIG.gradient.blendEnd },
            size0: { value: colorSettings.size0 },
            size1: { value: colorSettings.size1 },
            shadowIntensity: { value: colorSettings.shadowIntensity }
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            attribute float shadowFactor;
            attribute float heightFactor;
            uniform float size0;
            uniform float size1;
            varying float vDigit;
            varying float vShadowFactor;
            varying float vHeightFactor;
            void main() {
                vDigit = digit;
                vShadowFactor = shadowFactor;
                vHeightFactor = heightFactor;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                float finalSize = vDigit < 0.5 ? size0 : size1;
                gl_PointSize = finalSize * ${sizeMult} * (400.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 gradientTop;
            uniform vec3 gradientBottom;
            uniform float gradientIntensity;
            uniform float gradientBlendStart;
            uniform float gradientBlendEnd;
            uniform float shadowIntensity;
            varying float vDigit;
            varying float vShadowFactor;
            varying float vHeightFactor;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã—Å–æ—Ç—ã
                // vHeightFactor: 0.0 = –≤–µ—Ä—Ö (–±–µ–ª—ã–π), 1.0 = –Ω–∏–∑ (#2AF16B)
                float gradientT = clamp((vHeightFactor - gradientBlendStart) / (gradientBlendEnd - gradientBlendStart), 0.0, 1.0);
                vec3 gradientColor = mix(gradientTop, gradientBottom, gradientT);
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
                vec3 baseColor = mix(gradientTop, gradientColor, gradientIntensity);
                
                // –¢–µ–Ω–∏ —á–µ—Ä–µ–∑ opacity
                float finalOpacity = texColor.a * vShadowFactor;
                
                gl_FragColor = vec4(baseColor, finalOpacity);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });
    return new THREE.Points(geo, mat);
}

// –°–æ–∑–¥–∞–µ—Ç —Ñ–æ–Ω–æ–≤—ã–µ —á–∞—Å—Ç–∏—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ—Ç–∞—é—Ç –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
function createBackgroundParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const velocity = new Float32Array(count * 3);
    const radius = new Float32Array(count);
    
    const R = 120; // –†–∞–¥–∏—É—Å —Å—Ñ–µ—Ä—ã –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏

    for (let i = 0; i < count; i++) {
        // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å—Ñ–µ—Ä–µ
        const Œ∏ = Math.random() * 2 * Math.PI;
        const œÜ = Math.acos(2 * Math.random() - 1);
        const r = R + (Math.random() - 0.5) * 40;
        
        pos[i * 3] = r * Math.sin(œÜ) * Math.cos(Œ∏);
        pos[i * 3 + 1] = r * Math.sin(œÜ) * Math.sin(Œ∏);
        pos[i * 3 + 2] = r * Math.cos(œÜ);
        
        // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        velocity[i * 3] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        radius[i] = r;
        size[i] = 1.0 + Math.random() * 0.5;
        digit[i] = Math.random() < 0.5 ? 0.0 : 1.0;
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("velocity", new THREE.BufferAttribute(velocity, 3));
    geo.setAttribute("radius", new THREE.BufferAttribute(radius, 1));
    
    const sizeMult = CONFIG.digitSizeMultiplier.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            bgColor0: { value: colorSettings.bgColor0 },
            bgColor1: { value: colorSettings.bgColor1 }
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            varying float vDigit;
            void main() {
                vDigit = digit;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * ${sizeMult} * (300.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 bgColor0;
            uniform vec3 bgColor1;
            varying float vDigit;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–∏—Ñ—Ä—ã
                vec3 baseColor = vDigit < 0.5 ? bgColor0 : bgColor1;
                
                gl_FragColor = vec4(baseColor, texColor.a * 0.7);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });

    const points = new THREE.Points(geo, mat);
    points.userData.velocity = velocity;
    points.userData.radius = radius;
    return points;
}


function init() {
    digitTexture0 = createTextTexture('0', 256);
    digitTexture1 = createTextTexture('1', 256);
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050203, .012);

    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 2500);
    camera.position.set(0, 0, 80);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("container").appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 20;
    controls.maxDistance = 200;
    controls.target.set(0, 0, 0);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    particles = makeParticles(CONFIG.particleCount);
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    particles.material.uniforms.gradientTop.value = colorSettings.gradientTop;
    particles.material.uniforms.gradientBottom.value = colorSettings.gradientBottom;
    particles.material.uniforms.gradientIntensity.value = CONFIG.gradient.intensity;
    particles.material.uniforms.gradientBlendStart.value = CONFIG.gradient.blendStart;
    particles.material.uniforms.gradientBlendEnd.value = CONFIG.gradient.blendEnd;
    particles.material.uniforms.size0.value = colorSettings.size0;
    particles.material.uniforms.size1.value = colorSettings.size1;
    particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
    
    scene.add(particles);
    
    // –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –ª–µ—Ç–∞—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    backgroundParticles = createBackgroundParticles(CONFIG.backgroundParticleCount);
    backgroundParticles.material.uniforms.bgColor0.value = colorSettings.bgColor0;
    backgroundParticles.material.uniforms.bgColor1.value = colorSettings.bgColor1;
    scene.add(backgroundParticles);
    
    // –î–µ–ª–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    window.updateColors = () => {
        // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
        colorSettings.gradientTop.set(
            CONFIG.gradient.topColor.r / 255,
            CONFIG.gradient.topColor.g / 255,
            CONFIG.gradient.topColor.b / 255
        );
        colorSettings.gradientBottom.set(
            CONFIG.gradient.bottomColor.r / 255,
            CONFIG.gradient.bottomColor.g / 255,
            CONFIG.gradient.bottomColor.b / 255
        );
        
        particles.material.uniforms.gradientTop.value.copy(colorSettings.gradientTop);
        particles.material.uniforms.gradientBottom.value.copy(colorSettings.gradientBottom);
        particles.material.uniforms.gradientIntensity.value = CONFIG.gradient.intensity;
        particles.material.uniforms.gradientBlendStart.value = CONFIG.gradient.blendStart;
        particles.material.uniforms.gradientBlendEnd.value = CONFIG.gradient.blendEnd;
        particles.material.uniforms.size0.value = colorSettings.size0;
        particles.material.uniforms.size1.value = colorSettings.size1;
        particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
        colorSettings.bgColor0.set(
            CONFIG.backgroundColors.color0.r / 255,
            CONFIG.backgroundColors.color0.g / 255,
            CONFIG.backgroundColors.color0.b / 255
        );
        colorSettings.bgColor1.set(
            CONFIG.backgroundColors.color1.r / 255,
            CONFIG.backgroundColors.color1.g / 255,
            CONFIG.backgroundColors.color1.b / 255
        );
        
        if (backgroundParticles) {
            backgroundParticles.material.uniforms.bgColor0.value.copy(colorSettings.bgColor0);
            backgroundParticles.material.uniforms.bgColor1.value.copy(colorSettings.bgColor1);
        }
    };
    window.CONFIG = CONFIG;
    window.colorSettings = colorSettings;

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å –º–æ–∑–≥–∞
    loadModelPattern('assets/brain6/scene.gltf', CONFIG.particleCount)
        .then((data) => {
            applyPattern(data.points, data.normals);
        })
        .catch((error) => {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
        });

    addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
}

// –ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ç–æ—á–∫–∏ –º–æ–¥–µ–ª–∏ –∫ —á–∞—Å—Ç–∏—Ü–∞–º
// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ—Ä–º–∞–ª–∏ –∏–∑ –º–æ–¥–µ–ª–∏ –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è –∏–∑–≤–∏–ª–∏–Ω
function applyPattern(pts, normals){
    if (!pts || pts.length === 0) return;
    const particleArr = particles.geometry.attributes.position.array;
    const digitArr = particles.geometry.attributes.digit.array;
    const shadowFactorArr = particles.geometry.attributes.shadowFactor.array;
    const heightFactorArr = particles.geometry.attributes.heightFactor.array;
    
    // –°–æ–∑–¥–∞–µ–º –º–∞—Ç—Ä–∏—Ü—ã –ø–æ–≤–æ—Ä–æ—Ç–∞
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationFromEuler(new THREE.Euler(
        CONFIG.modelRotation.x,
        CONFIG.modelRotation.y,
        CONFIG.modelRotation.z,
        'XYZ'
    ));
    const normalRotationMatrix = new THREE.Matrix3().getNormalMatrix(rotationMatrix);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –∫ —Ç–æ—á–∫–∞–º –∏ –Ω–æ—Ä–º–∞–ª—è–º
    const rotatedPts = [];
    const rotatedNormals = [];
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const n = normals[i];
        if (!p) {
            rotatedPts.push(null);
            rotatedNormals.push(null);
            continue;
        }
        rotatedPts.push(p.clone().applyMatrix4(rotationMatrix));
        rotatedNormals.push(n ? n.clone().applyMatrix3(normalRotationMatrix).normalize() : new THREE.Vector3(0, 1, 0));
    }
    
    // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –º–æ–¥–µ–ª–∏ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    let minY = Infinity, maxY = -Infinity;
    for (let i = 0; i < rotatedPts.length; i++) {
        if (rotatedPts[i]) {
            minY = Math.min(minY, rotatedPts[i].y);
            maxY = Math.max(maxY, rotatedPts[i].y);
        }
    }
    const heightRange = maxY - minY || 1.0;
    
    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞
    const lightDir = new THREE.Vector3(
        CONFIG.lighting.lightDirection.x,
        CONFIG.lighting.lightDirection.y,
        CONFIG.lighting.lightDirection.z
    ).normalize();
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Ç–æ—á–∫–∏
    for (let j = 0; j < CONFIG.particleCount; j++) {
        const idx = j * 3;
        const p = rotatedPts[j];
        const n = rotatedNormals[j];
        if (!p) continue;
        
        particleArr[idx] = p.x;
        particleArr[idx + 1] = p.y;
        particleArr[idx + 2] = p.z;
        
        digitArr[j] = hashPosition(p.x, p.y, p.z);
        
        // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –≤—ã—Å–æ—Ç—É –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ (0.0 = –≤–µ—Ä—Ö, 1.0 = –Ω–∏–∑)
        const normalizedHeight = heightRange > 0 ? (p.y - minY) / heightRange : 0.5;
        heightFactorArr[j] = normalizedHeight;
        
        // –û—Å–≤–µ—â–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ—Ä–º–∞–ª–µ–π (Lambertian)
        const NdotL = n.dot(lightDir);
        const halfLambert = NdotL * 0.5 + 0.5;
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π
        const ambient = 1.0 - colorSettings.shadowIntensity;
        let shadowFactor = ambient + halfLambert * colorSettings.shadowIntensity;
        shadowFactor = Math.max(0.05, Math.min(1.0, shadowFactor));
        
        shadowFactorArr[j] = shadowFactor;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.digit.needsUpdate = true;
    particles.geometry.attributes.shadowFactor.needsUpdate = true;
    particles.geometry.attributes.heightFactor.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    controls.update();

    // –ê–Ω–∏–º–∞—Ü–∏—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü - –ø–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
    if (backgroundParticles) {
        const posArr = backgroundParticles.geometry.attributes.position.array;
        const velArr = backgroundParticles.userData.velocity;
        const radArr = backgroundParticles.userData.radius;
        
        for (let i = 0; i < CONFIG.backgroundParticleCount; i++) {
            const i3 = i * 3;
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            posArr[i3] += velArr[i3] * dt * 10;
            posArr[i3 + 1] += velArr[i3 + 1] * dt * 10;
            posArr[i3 + 2] += velArr[i3 + 2] * dt * 10;
            
            // –£–¥–µ—Ä–∂–∏–≤–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Å—Ñ–µ—Ä—ã
            const dist = Math.sqrt(posArr[i3]**2 + posArr[i3+1]**2 + posArr[i3+2]**2);
            const maxDist = radArr[i] * 1.3;
            if (dist > maxDist || dist < radArr[i] * 0.7) {
                const scale = (dist > maxDist ? radArr[i] * 0.7 : maxDist) / dist;
                posArr[i3] *= scale;
                posArr[i3 + 1] *= scale;
                posArr[i3 + 2] *= scale;
            }
        }
        backgroundParticles.geometry.attributes.position.needsUpdate = true;
    }

    renderer.render(scene, camera);
}

init();
animate();
</script>