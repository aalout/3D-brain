<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Morphing Shapes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

<style>
    *, *::before, *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        font-family: "Inter", sans-serif;
        overflow: hidden;
        background: #040307; 
        color: #eee;
    }
    #container {
        position: fixed;
        inset: 0;
    }
    .vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 9;
        background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%);
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .instructions {
        position: fixed;
        left: 24px;
        bottom: 24px;
        transform: none;
        padding: 10px 20px;
        font-size: 12px;
        text-align: left;
        pointer-events: none;
        color: #d0b0ff;
        background: rgba(18, 15, 40, 0.25);
        border: 1px solid rgba(122, 70, 255, 0.28);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
    }

</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<div id="container"></div>
<div class="vignette"></div>
<div class="instructions"></div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

const CONFIG = {
    backgroundParticleCount: 5000,
    digitSizeMultiplier: 1.2,
    
    // Поворот модели (в радианах)
    modelRotation: {
        x: -(Math.PI / 2),
        y: 0,
        z: Math.PI
    },
    
    // Цвета градиента (RGB 0-255)
    gradient: {
        topColor: { r: 42, g: 241, b: 107 },
        bottomColor: { r: 255, g: 255, b: 255 },
        intensity: 1.0,
        blendStart: 0.2,
        blendEnd: 1.0
    },
    
    // Цвета для фоновых частиц
    backgroundColors: {
        color0: { r: 255, g: 255, b: 255 },
        color1: { r: 42, g: 241, b: 107 }
    },
    
    // Размеры частиц
    particleSizes: {
        size0: 1.0,
        size1: 1.0
    },
    
    // Освещение и тени
    lighting: {
        shadowIntensity: 0.95,
        lightDirection: { x: 0.3, y: 1.0, z: 0.5 }
    }
};

const colorSettings = {
    gradientTop: new THREE.Vector3(
        CONFIG.gradient.topColor.r / 255,
        CONFIG.gradient.topColor.g / 255,
        CONFIG.gradient.topColor.b / 255
    ),
    gradientBottom: new THREE.Vector3(
        CONFIG.gradient.bottomColor.r / 255,
        CONFIG.gradient.bottomColor.g / 255,
        CONFIG.gradient.bottomColor.b / 255
    ),
    bgColor0: new THREE.Vector3(
        CONFIG.backgroundColors.color0.r / 255,
        CONFIG.backgroundColors.color0.g / 255,
        CONFIG.backgroundColors.color0.b / 255
    ),
    bgColor1: new THREE.Vector3(
        CONFIG.backgroundColors.color1.r / 255,
        CONFIG.backgroundColors.color1.g / 255,
        CONFIG.backgroundColors.color1.b / 255
    ),
    size0: CONFIG.particleSizes.size0,
    size1: CONFIG.particleSizes.size1,
    shadowIntensity: CONFIG.lighting.shadowIntensity
};

let scene, camera, renderer, controls;
let particles, backgroundParticles;
let clock = new THREE.Clock();
let digitTexture0, digitTexture1;

function normalise(points, size) {
    if (points.length === 0) return [];
    const box = new THREE.Box3().setFromPoints(points);
    const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1;
    const centre = box.getCenter(new THREE.Vector3());
    return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim));
}

async function loadModelPattern(modelPath) {
    return new Promise((resolve, reject) => {
        const loader = new GLTFLoader();
        loader.load(
            modelPath,
            (gltf) => {
                const points = [];
                const normals = [];
                
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        const positionAttribute = geometry.attributes.position;
                        const normalAttribute = geometry.attributes.normal;
                        
                        child.updateMatrixWorld();
                        const worldMatrix = child.matrixWorld;
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(worldMatrix);
                        
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                            vertex.applyMatrix4(worldMatrix);
                            points.push(vertex);
                            
                            if (normalAttribute) {
                                const normal = new THREE.Vector3().fromBufferAttribute(normalAttribute, i);
                                normal.applyMatrix3(normalMatrix).normalize();
                                normals.push(normal);
                            } else {
                                normals.push(new THREE.Vector3(0, 1, 0));
                            }
                        }
                    }
                });
                
                if (points.length === 0) {
                    reject(new Error('Модель не содержит вершин'));
                    return;
                }
                
                const normalizedPoints = normalise(points, 50);
                
                resolve({ points: normalizedPoints, normals: normals });
            },
            undefined,
            (error) => {
                reject(error);
            }
        );
    });
}

function createTextTexture(text, size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size * 0.8}px Inter, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    if (text === '1') {
        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI);
        ctx.scale(-1, 1);
        ctx.translate(-size / 2, -size / 2);
    }
    
    ctx.fillText(text, size / 2, size / 2);
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

function hashPosition(x, y, z) {
    const hash = ((x * 73856093) ^ (y * 19349663) ^ (z * 83492791)) >>> 0;
    return hash % 2;
}

function makeParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const shadowFactor = new Float32Array(count);
    const heightFactor = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
        size[i] = 2.0;
        digit[i] = 0.0;
        shadowFactor[i] = 1.0;
        heightFactor[i] = 0.5;
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("shadowFactor", new THREE.BufferAttribute(shadowFactor, 1));
    geo.setAttribute("heightFactor", new THREE.BufferAttribute(heightFactor, 1));
    
    const sizeMult = CONFIG.digitSizeMultiplier.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            gradientTop: { value: colorSettings.gradientTop },
            gradientBottom: { value: colorSettings.gradientBottom },
            gradientIntensity: { value: CONFIG.gradient.intensity },
            gradientBlendStart: { value: CONFIG.gradient.blendStart },
            gradientBlendEnd: { value: CONFIG.gradient.blendEnd },
            size0: { value: colorSettings.size0 },
            size1: { value: colorSettings.size1 },
            shadowIntensity: { value: colorSettings.shadowIntensity }
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            attribute float shadowFactor;
            attribute float heightFactor;
            uniform float size0;
            uniform float size1;
            varying float vDigit;
            varying float vShadowFactor;
            varying float vHeightFactor;
            void main() {
                vDigit = digit;
                vShadowFactor = shadowFactor;
                vHeightFactor = heightFactor;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                float finalSize = vDigit < 0.5 ? size0 : size1;
                gl_PointSize = finalSize * ${sizeMult} * (400.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 gradientTop;
            uniform vec3 gradientBottom;
            uniform float gradientIntensity;
            uniform float gradientBlendStart;
            uniform float gradientBlendEnd;
            uniform float shadowIntensity;
            varying float vDigit;
            varying float vShadowFactor;
            varying float vHeightFactor;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                float gradientT = clamp((vHeightFactor - gradientBlendStart) / (gradientBlendEnd - gradientBlendStart), 0.0, 1.0);
                vec3 gradientColor = mix(gradientTop, gradientBottom, gradientT);
                
                vec3 baseColor = mix(gradientTop, gradientColor, gradientIntensity);
                
                float finalOpacity = texColor.a * vShadowFactor;
                
                gl_FragColor = vec4(baseColor, finalOpacity);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });
    return new THREE.Points(geo, mat);
}

function createBackgroundParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const velocity = new Float32Array(count * 3);
    const radius = new Float32Array(count);
    
    const R = 120;

    for (let i = 0; i < count; i++) {
        const θ = Math.random() * 2 * Math.PI;
        const φ = Math.acos(2 * Math.random() - 1);
        const r = R + (Math.random() - 0.5) * 40;
        
        pos[i * 3] = r * Math.sin(φ) * Math.cos(θ);
        pos[i * 3 + 1] = r * Math.sin(φ) * Math.sin(θ);
        pos[i * 3 + 2] = r * Math.cos(φ);
        
        velocity[i * 3] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        radius[i] = r;
        size[i] = 1.0 + Math.random() * 0.5;
        digit[i] = Math.random() < 0.5 ? 0.0 : 1.0;
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("velocity", new THREE.BufferAttribute(velocity, 3));
    geo.setAttribute("radius", new THREE.BufferAttribute(radius, 1));
    
    const sizeMult = CONFIG.digitSizeMultiplier.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            bgColor0: { value: colorSettings.bgColor0 },
            bgColor1: { value: colorSettings.bgColor1 }
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            varying float vDigit;
            void main() {
                vDigit = digit;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * ${sizeMult} * (300.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 bgColor0;
            uniform vec3 bgColor1;
            varying float vDigit;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                vec3 baseColor = vDigit < 0.5 ? bgColor0 : bgColor1;
                
                gl_FragColor = vec4(baseColor, texColor.a * 0.7);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });

    const points = new THREE.Points(geo, mat);
    points.userData.velocity = velocity;
    points.userData.radius = radius;
    return points;
}


function init() {
    digitTexture0 = createTextTexture('0', 256);
    digitTexture1 = createTextTexture('1', 256);
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050203, .012);

    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 2500);
    camera.position.set(0, 0, 80);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("container").appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableRotate = false;
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.screenSpacePanning = false;
    controls.minDistance = 20;
    controls.maxDistance = 200;
    controls.target.set(0, 0, 0);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    backgroundParticles = createBackgroundParticles(CONFIG.backgroundParticleCount);
    backgroundParticles.material.uniforms.bgColor0.value = colorSettings.bgColor0;
    backgroundParticles.material.uniforms.bgColor1.value = colorSettings.bgColor1;
    scene.add(backgroundParticles);

    loadModelPattern('assets/brain7/1234.gltf')
        .then((data) => {
            const particleCount = data.points.length;
            particles = makeParticles(particleCount);
            particles.material.uniforms.gradientTop.value = colorSettings.gradientTop;
            particles.material.uniforms.gradientBottom.value = colorSettings.gradientBottom;
            particles.material.uniforms.gradientIntensity.value = CONFIG.gradient.intensity;
            particles.material.uniforms.gradientBlendStart.value = CONFIG.gradient.blendStart;
            particles.material.uniforms.gradientBlendEnd.value = CONFIG.gradient.blendEnd;
            particles.material.uniforms.size0.value = colorSettings.size0;
            particles.material.uniforms.size1.value = colorSettings.size1;
            particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
            
            scene.add(particles);
            applyPattern(data.points, data.normals);
        })
        .catch(() => {});

    addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
}

function applyPattern(pts, normals){
    if (!pts || pts.length === 0) return;
    const particleCount = pts.length;
    const particleArr = particles.geometry.attributes.position.array;
    const digitArr = particles.geometry.attributes.digit.array;
    const shadowFactorArr = particles.geometry.attributes.shadowFactor.array;
    const heightFactorArr = particles.geometry.attributes.heightFactor.array;
    
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationFromEuler(new THREE.Euler(
        CONFIG.modelRotation.x,
        CONFIG.modelRotation.y,
        CONFIG.modelRotation.z,
        'XYZ'
    ));
    const normalRotationMatrix = new THREE.Matrix3().getNormalMatrix(rotationMatrix);
    
    const rotatedPts = [];
    const rotatedNormals = [];
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const n = normals[i];
        if (!p) {
            rotatedPts.push(null);
            rotatedNormals.push(null);
            continue;
        }
        rotatedPts.push(p.clone().applyMatrix4(rotationMatrix));
        rotatedNormals.push(n ? n.clone().applyMatrix3(normalRotationMatrix).normalize() : new THREE.Vector3(0, 1, 0));
    }
    
    let minY = Infinity, maxY = -Infinity;
    for (let i = 0; i < rotatedPts.length; i++) {
        if (rotatedPts[i]) {
            minY = Math.min(minY, rotatedPts[i].y);
            maxY = Math.max(maxY, rotatedPts[i].y);
        }
    }
    const heightRange = maxY - minY || 1.0;
    
    const lightDir = new THREE.Vector3(
        CONFIG.lighting.lightDirection.x,
        CONFIG.lighting.lightDirection.y,
        CONFIG.lighting.lightDirection.z
    ).normalize();
    
    for (let j = 0; j < particleCount; j++) {
        const idx = j * 3;
        const p = rotatedPts[j];
        const n = rotatedNormals[j];
        if (!p) continue;
        
        particleArr[idx] = p.x;
        particleArr[idx + 1] = p.y;
        particleArr[idx + 2] = p.z;
        
        digitArr[j] = hashPosition(p.x, p.y, p.z);
        
        const normalizedHeight = heightRange > 0 ? (p.y - minY) / heightRange : 0.5;
        heightFactorArr[j] = normalizedHeight;
        
        const NdotL = n.dot(lightDir);
        const halfLambert = NdotL * 0.5 + 0.5;
        
        const ambient = 1.0 - colorSettings.shadowIntensity;
        let shadowFactor = ambient + halfLambert * colorSettings.shadowIntensity;
        shadowFactor = Math.max(0.05, Math.min(1.0, shadowFactor));
        
        shadowFactorArr[j] = shadowFactor;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.digit.needsUpdate = true;
    particles.geometry.attributes.shadowFactor.needsUpdate = true;
    particles.geometry.attributes.heightFactor.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    controls.update();

    if (backgroundParticles) {
        const posArr = backgroundParticles.geometry.attributes.position.array;
        const velArr = backgroundParticles.userData.velocity;
        const radArr = backgroundParticles.userData.radius;
        
        for (let i = 0; i < CONFIG.backgroundParticleCount; i++) {
            const i3 = i * 3;
            posArr[i3] += velArr[i3] * dt * 10;
            posArr[i3 + 1] += velArr[i3 + 1] * dt * 10;
            posArr[i3 + 2] += velArr[i3 + 2] * dt * 10;
            
            const dist = Math.sqrt(posArr[i3]**2 + posArr[i3+1]**2 + posArr[i3+2]**2);
            const maxDist = radArr[i] * 1.3;
            if (dist > maxDist || dist < radArr[i] * 0.7) {
                const scale = (dist > maxDist ? radArr[i] * 0.7 : maxDist) / dist;
                posArr[i3] *= scale;
                posArr[i3 + 1] *= scale;
                posArr[i3 + 2] *= scale;
            }
        }
        backgroundParticles.geometry.attributes.position.needsUpdate = true;
    }

    renderer.render(scene, camera);
}

init();
animate();
</script>