<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Morphing Shapes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

<style>
    *, *::before, *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        font-family: "Inter", sans-serif;
        overflow: hidden;
        background: #040307; 
        background-image:
            radial-gradient(circle at 50% 35%, #1d1431 0%, transparent 65%),
            linear-gradient(180deg, #000000 0%, #070012 100%);
        color: #eee;
    }
    #container {
        position: fixed;
        inset: 0;
    }
    .vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 9;
        background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%);
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .instructions {
        position: fixed;
        left: 24px;
        bottom: 24px;
        transform: none;
        padding: 10px 20px;
        font-size: 12px;
        text-align: left;
        pointer-events: none;
        color: #d0b0ff;
        background: rgba(18, 15, 40, 0.25);
        border: 1px solid rgba(122, 70, 255, 0.28);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
    }

</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<div id="container"></div>
<div class="vignette"></div>
<div class="instructions">Drag to explore</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

const PARTICLE_COUNT = 325340;
const BACKGROUND_PARTICLE_COUNT = 5000; // –õ–µ—Ç–∞—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
const DIGIT_SIZE_MULTIPLIER = 0.7; // –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–∞–∑–º–µ—Ä–∞ —Ü–∏—Ñ—Ä

// –ü–æ–≤–æ—Ä–æ—Ç –º–æ–¥–µ–ª–∏ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö)
const MODEL_ROTATION = {
    x: - (Math.PI / 2), // –ü–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ –æ—Å–∏ X (180 –≥—Ä–∞–¥—É—Å–æ–≤)
    y: 0,       // –ü–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Y
    z: Math.PI        // –ü–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Z
};

const colorSettings = {
    color0: new THREE.Vector3(1.0, 1.0, 1.0), // –¶–≤–µ—Ç –¥–ª—è –Ω—É–ª–µ–π (–±–µ–ª—ã–π) RGB 0-1
    color1: new THREE.Vector3(42/255, 241/255, 107/255), // –¶–≤–µ—Ç –¥–ª—è –µ–¥–∏–Ω–∏—Ü rgb(42, 241, 107) RGB 0-1
    bgColor0: new THREE.Vector3(1.0, 1.0, 1.0), // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –Ω—É–ª–µ–π (–±–µ–ª—ã–π) RGB 0-1
    bgColor1: new THREE.Vector3(42/255, 241/255, 107/255), // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü rgb(42, 241, 107) RGB 0-1
    size0: 1.0, // –†–∞–∑–º–µ—Ä –Ω—É–ª–µ–π
    size1: 1.0, // –†–∞–∑–º–µ—Ä –µ–¥–∏–Ω–∏—Ü
    shadowIntensity: 0.75 // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π (0.0 - –Ω–µ—Ç —Ç–µ–Ω–µ–π, 1.0 - –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ —Ç–µ–Ω–∏)
};

let scene, camera, renderer, controls;
let particles, backgroundParticles;
let clock = new THREE.Clock();
let digitTexture0, digitTexture1;

function normalise(points, size) {
    if (points.length === 0) return [];
    const box = new THREE.Box3().setFromPoints(points);
    const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1;
    const centre = box.getCenter(new THREE.Vector3());
    return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim));
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤–µ—Ä—à–∏–Ω –∏–∑ 3D –º–æ–¥–µ–ª–∏
async function loadModelPattern(modelPath, targetCount) {
    return new Promise((resolve, reject) => {
        const loader = new GLTFLoader();
        loader.load(
            modelPath,
            (gltf) => {
                const points = [];
                
                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –≤—Å–µ –º–µ—à–∏ –≤ –º–æ–¥–µ–ª–∏
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        const positionAttribute = geometry.attributes.position;
                        
                        // –ü–æ–ª—É—á–∞–µ–º –º–∏—Ä–æ–≤—É—é –º–∞—Ç—Ä–∏—Ü—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                        child.updateMatrixWorld();
                        const worldMatrix = child.matrixWorld;
                        
                        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                            vertex.applyMatrix4(worldMatrix);
                            points.push(vertex);
                        }
                    }
                });
                
                // –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –≤–µ—Ä—à–∏–Ω –≤ –∫–æ–Ω—Å–æ–ª—å
                const uniqueVertexCount = points.length;
                console.log(`üìä –ú–æ–¥–µ–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç ${uniqueVertexCount} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω`);
                console.log(`üéØ –ó–∞–ø—Ä–æ—à–µ–Ω–æ —á–∞—Å—Ç–∏—Ü: ${targetCount}`);
                
                if (uniqueVertexCount < targetCount) {
                    console.warn(`‚ö†Ô∏è PARTICLE_COUNT (${targetCount}) –±–æ–ª—å—à–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–µ—Ä—à–∏–Ω –º–æ–¥–µ–ª–∏ (${uniqueVertexCount}). –ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –¥—É–±–ª–∏–∫–∞—Ç—ã.`);
                    console.log(`üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å PARTICLE_COUNT <= ${uniqueVertexCount} –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è`);
                } else {
                    console.log(`‚úÖ –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–µ—Ä—à–∏–Ω –¥–ª—è ${targetCount} —á–∞—Å—Ç–∏—Ü`);
                }
                
                // –†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –≤–µ—Ä—à–∏–Ω –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã
                // –í–º–µ—Å—Ç–æ —Å–ª—É—á–∞–π–Ω–æ–≥–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
                const result = [];
                if (points.length === 0) {
                    reject(new Error('–ú–æ–¥–µ–ª—å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ—Ä—à–∏–Ω'));
                    return;
                }
                
                if (points.length >= targetCount) {
                    // –†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä: –±–µ—Ä–µ–º –∫–∞–∂–¥—É—é N-—é –≤–µ—Ä—à–∏–Ω—É
                    // –≠—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ñ–æ—Ä–º—É –ª—É—á—à–µ, —á–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä
                    const step = points.length / targetCount;
                    for (let i = 0; i < targetCount; i++) {
                        const idx = Math.floor(i * step);
                        result.push(points[idx].clone());
                    }
                } else {
                    // –ï—Å–ª–∏ –≤–µ—Ä—à–∏–Ω –º–µ–Ω—å—à–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å–µ –∏ –¥–æ–ø–æ–ª–Ω—è–µ–º —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ
                    result.push(...points.map(p => p.clone()));
                    
                    // –î–æ–ø–æ–ª–Ω—è–µ–º —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –≤–µ—Ä—à–∏–Ω
                    while (result.length < targetCount) {
                        const idx = result.length % points.length;
                        result.push(points[idx].clone());
                    }
                }
                
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
                resolve(normalise(result, 50));
            },
            undefined,
            (error) => {
                reject(error);
            }
        );
    });
}

function createTextTexture(text, size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size * 0.8}px Inter, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // –ï—Å–ª–∏ —ç—Ç–æ "1", –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤ –∏ –æ—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º
    if (text === '1') {
        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI);
        ctx.scale(-1, 1); // –û—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        ctx.translate(-size / 2, -size / 2);
    }
    
    ctx.fillText(text, size / 2, size / 2);
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

// –ü—Ä–æ—Å—Ç–∞—è —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è —Ü–∏—Ñ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏
function hashPosition(x, y, z) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    const hash = ((x * 73856093) ^ (y * 19349663) ^ (z * 83492791)) >>> 0;
    return hash % 2; // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0 –∏–ª–∏ 1
}

function makeParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const shadowFactor = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
        size[i] = 2.0; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –æ–±—ä–µ–º–∞
        // –¶–∏—Ñ—Ä–∞ –±—É–¥–µ—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏ –≤ applyPattern
        digit[i] = 0.0; // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ
        shadowFactor[i] = 1.0; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∑–∞—Ç–µ–º–Ω–µ–Ω–∏—è (1.0 = –±–µ–∑ —Ç–µ–Ω–∏, 0.0 = –ø–æ–ª–Ω–∞—è —Ç–µ–Ω—å)
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("shadowFactor", new THREE.BufferAttribute(shadowFactor, 1));
    
    const sizeMult = DIGIT_SIZE_MULTIPLIER.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            color0: { value: new THREE.Vector3(1.0, 1.0, 1.0) }, // –¶–≤–µ—Ç –¥–ª—è –Ω—É–ª–µ–π (–±–µ–ª—ã–π)
            color1: { value: new THREE.Vector3(42/255, 241/255, 107/255) }, // –¶–≤–µ—Ç –¥–ª—è –µ–¥–∏–Ω–∏—Ü rgb(42, 241, 107)
            size0: { value: 2.0 }, // –†–∞–∑–º–µ—Ä –Ω—É–ª–µ–π
            size1: { value: 2.0 }, // –†–∞–∑–º–µ—Ä –µ–¥–∏–Ω–∏—Ü
            shadowIntensity: { value: 0.7 } // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            attribute float shadowFactor;
            uniform float size0;
            uniform float size1;
            varying float vDigit;
            varying float vShadowFactor;
            varying vec3 vPosition;
            void main() {
                vDigit = digit;
                vShadowFactor = shadowFactor;
                vPosition = position;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                float finalSize = vDigit < 0.5 ? size0 : size1;
                gl_PointSize = finalSize * ${sizeMult} * (400.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 color0;
            uniform vec3 color1;
            uniform float shadowIntensity;
            varying float vDigit;
            varying float vShadowFactor;
            varying vec3 vPosition;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–∏—Ñ—Ä—ã
                vec3 baseColor = vDigit < 0.5 ? color0 : color1;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–Ω–∏ —á–µ—Ä–µ–∑ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ (–Ω–µ opacity!)
                // vShadowFactor: 1.0 = –ø–æ–ª–Ω—ã–π —Å–≤–µ—Ç, 0.0 = –ø–æ–ª–Ω–∞—è —Ç–µ–Ω—å
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –¥–ª—è –ª—É—á—à–∏—Ö —Ç–µ–Ω–µ–π
                float shadowDarkness = 1.0 - (1.0 - vShadowFactor) * shadowIntensity;
                vec3 shadowedColor = baseColor * shadowDarkness;
                
                gl_FragColor = vec4(shadowedColor, texColor.a);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });
    return new THREE.Points(geo, mat);
}

// –°–æ–∑–¥–∞–µ—Ç —Ñ–æ–Ω–æ–≤—ã–µ —á–∞—Å—Ç–∏—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ—Ç–∞—é—Ç –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
function createBackgroundParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const velocity = new Float32Array(count * 3);
    const radius = new Float32Array(count);
    
    const R = 120; // –†–∞–¥–∏—É—Å —Å—Ñ–µ—Ä—ã –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏

    for (let i = 0; i < count; i++) {
        // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å—Ñ–µ—Ä–µ
        const Œ∏ = Math.random() * 2 * Math.PI;
        const œÜ = Math.acos(2 * Math.random() - 1);
        const r = R + (Math.random() - 0.5) * 40;
        
        pos[i * 3] = r * Math.sin(œÜ) * Math.cos(Œ∏);
        pos[i * 3 + 1] = r * Math.sin(œÜ) * Math.sin(Œ∏);
        pos[i * 3 + 2] = r * Math.cos(œÜ);
        
        // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        velocity[i * 3] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        radius[i] = r;
        size[i] = 1.0 + Math.random() * 0.5;
        digit[i] = Math.random() < 0.5 ? 0.0 : 1.0;
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("velocity", new THREE.BufferAttribute(velocity, 3));
    geo.setAttribute("radius", new THREE.BufferAttribute(radius, 1));
    
    const sizeMult = DIGIT_SIZE_MULTIPLIER.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            bgColor0: { value: new THREE.Vector3(1.0, 1.0, 1.0) }, // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –Ω—É–ª–µ–π
            bgColor1: { value: new THREE.Vector3(42/255, 241/255, 107/255) } // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            varying float vDigit;
            void main() {
                vDigit = digit;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * ${sizeMult} * (300.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 bgColor0;
            uniform vec3 bgColor1;
            varying float vDigit;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–∏—Ñ—Ä—ã
                vec3 baseColor = vDigit < 0.5 ? bgColor0 : bgColor1;
                
                gl_FragColor = vec4(baseColor, texColor.a * 0.7);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });

    const points = new THREE.Points(geo, mat);
    points.userData.velocity = velocity;
    points.userData.radius = radius;
    return points;
}


function init() {
    digitTexture0 = createTextTexture('0', 256);
    digitTexture1 = createTextTexture('1', 256);
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050203, .012);

    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 2500);
    camera.position.set(0, 0, 80);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("container").appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 20;
    controls.maxDistance = 200;
    controls.target.set(0, 0, 0);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    particles = makeParticles(PARTICLE_COUNT);
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ü–≤–µ—Ç–æ–≤, —Ä–∞–∑–º–µ—Ä–æ–≤ –∏ —Ç–µ–Ω–µ–π
    particles.material.uniforms.color0.value = colorSettings.color0;
    particles.material.uniforms.color1.value = colorSettings.color1;
    particles.material.uniforms.size0.value = colorSettings.size0;
    particles.material.uniforms.size1.value = colorSettings.size1;
    particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
    
    scene.add(particles);
    
    // –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –ª–µ—Ç–∞—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    backgroundParticles = createBackgroundParticles(BACKGROUND_PARTICLE_COUNT);
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
    backgroundParticles.material.uniforms.bgColor0.value = colorSettings.bgColor0;
    backgroundParticles.material.uniforms.bgColor1.value = colorSettings.bgColor1;
    scene.add(backgroundParticles);
    
    // –î–µ–ª–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    window.updateColors = () => {
        particles.material.uniforms.color0.value.copy(colorSettings.color0);
        particles.material.uniforms.color1.value.copy(colorSettings.color1);
        particles.material.uniforms.size0.value = colorSettings.size0;
        particles.material.uniforms.size1.value = colorSettings.size1;
        particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
        if (backgroundParticles) {
            backgroundParticles.material.uniforms.bgColor0.value.copy(colorSettings.bgColor0);
            backgroundParticles.material.uniforms.bgColor1.value.copy(colorSettings.bgColor1);
        }
    };
    window.colorSettings = colorSettings;

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å –º–æ–∑–≥–∞
    loadModelPattern('assets/brain2/scene.gltf', PARTICLE_COUNT)
        .then((brainPoints) => {
            applyPattern(brainPoints);
        })
        .catch((error) => {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
        });

    addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
}

// –ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ç–æ—á–∫–∏ –º–æ–¥–µ–ª–∏ –∫ —á–∞—Å—Ç–∏—Ü–∞–º
// –¶–∏—Ñ—Ä—ã 0 –∏ 1 –ø—Ä–∏—Å–≤–∞–∏–≤–∞—é—Ç—Å—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏
// –ó–¥–µ—Å—å —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è –ü–û–ó–ò–¶–ò–ò, –¶–ò–§–†–´ –∏ SHADOW_FACTOR –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Ç–µ–Ω–µ–π
function applyPattern(pts){
    if (!pts || pts.length === 0) return;
    const particleArr = particles.geometry.attributes.position.array;
    const digitArr = particles.geometry.attributes.digit.array;
    const shadowFactorArr = particles.geometry.attributes.shadowFactor.array;
    
    // –°–æ–∑–¥–∞–µ–º –º–∞—Ç—Ä–∏—Ü—É –ø–æ–≤–æ—Ä–æ—Ç–∞
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationFromEuler(new THREE.Euler(MODEL_ROTATION.x, MODEL_ROTATION.y, MODEL_ROTATION.z, 'XYZ'));
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –∫ —Ç–æ—á–∫–∞–º
    const rotatedPts = pts.map(p => {
        if(!p) return p;
        const rotated = p.clone().applyMatrix4(rotationMatrix);
        return rotated;
    });
    
    // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –º–æ–¥–µ–ª–∏
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    for(let j=0; j<PARTICLE_COUNT; j++){
        const p = rotatedPts[j];
        if(!p) continue;
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
        minZ = Math.min(minZ, p.z);
        maxZ = Math.max(maxZ, p.z);
    }
    
    const heightRange = maxY - minY;
    const lightDirection = new THREE.Vector3(0.3, -1, 0.2).normalize();
    
    // –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–µ—Ç–∫–∞ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Å–æ—Å–µ–¥–µ–π (O(n) –≤–º–µ—Å—Ç–æ O(n¬≤))
    const gridSize = Math.ceil(Math.pow(PARTICLE_COUNT, 1/3) * 0.5); // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏
    const cellSize = Math.max(
        (maxX - minX) / gridSize,
        (maxY - minY) / gridSize,
        (maxZ - minZ) / gridSize,
        0.001
    );
    const grid = new Map();
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–µ—Ç–∫—É –∏–Ω–¥–µ–∫—Å–∞–º–∏ —Ç–æ—á–µ–∫
    for(let j=0; j<PARTICLE_COUNT; j++){
        const p = rotatedPts[j];
        if(!p) continue;
        const gx = Math.floor((p.x - minX) / cellSize);
        const gy = Math.floor((p.y - minY) / cellSize);
        const gz = Math.floor((p.z - minZ) / cellSize);
        const key = `${gx},${gy},${gz}`;
        if(!grid.has(key)) grid.set(key, []);
        grid.get(key).push(j);
    }
    
    const shadowCheckRadius = cellSize * 2.5; // –†–∞–¥–∏—É—Å –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–µ–Ω–µ–π
    const shadowCheckRadiusSq = shadowCheckRadius * shadowCheckRadius;
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ—Å–µ–¥–Ω–∏—Ö —è—á–µ–µ–∫
    const getNeighborCells = (gx, gy, gz) => {
        const neighbors = [];
        for(let dx = -1; dx <= 1; dx++){
            for(let dy = -1; dy <= 1; dy++){
                for(let dz = -1; dz <= 1; dz++){
                    neighbors.push(`${gx+dx},${gy+dy},${gz+dz}`);
                }
            }
        }
        return neighbors;
    };
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Ç–æ—á–∫–∏
    for(let j=0; j<PARTICLE_COUNT; j++){
        const idx = j*3;
        const p = rotatedPts[j];
        if(!p) continue;
        
        particleArr[idx] = p.x;
        particleArr[idx+1] = p.y;
        particleArr[idx+2] = p.z;
        
        digitArr[j] = hashPosition(p.x, p.y, p.z);
        
        // –ë—ã—Å—Ç—Ä–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ç–µ–Ω–µ–π —á–µ—Ä–µ–∑ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—É—é —Å–µ—Ç–∫—É
        let shadowAmount = 0.0;
        const gx = Math.floor((p.x - minX) / cellSize);
        const gy = Math.floor((p.y - minY) / cellSize);
        const gz = Math.floor((p.z - minZ) / cellSize);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ —Å–æ—Å–µ–¥–Ω–∏–µ —è—á–µ–π–∫–∏
        const neighborKeys = getNeighborCells(gx, gy, gz);
        let checkedCount = 0;
        const maxChecks = 50; // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–≤–µ—Ä–æ–∫ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        
        for(const key of neighborKeys){
            const cellPoints = grid.get(key);
            if(!cellPoints) continue;
            
            for(const k of cellPoints){
                if(k === j || checkedCount >= maxChecks) continue;
                checkedCount++;
                
                const otherP = rotatedPts[k];
                if(!otherP) continue;
                
                // –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (–±–µ–∑ sqrt)
                const dx = otherP.x - p.x;
                const dy = otherP.y - p.y;
                const dz = otherP.z - p.z;
                const distSq = dx*dx + dy*dy + dz*dz;
                
                if(distSq < shadowCheckRadiusSq && distSq > 0.0001){
                    const dist = Math.sqrt(distSq);
                    const invDist = 1.0 / dist;
                    
                    // –ë—ã—Å—Ç—Ä–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ dot product –±–µ–∑ —Å–æ–∑–¥–∞–Ω–∏—è Vector3
                    const dotProduct = (dx * lightDirection.x + dy * lightDirection.y + dz * lightDirection.z) * invDist;
                    
                    if(dotProduct > 0.3 && otherP.y > p.y){
                        const heightDiff = otherP.y - p.y;
                        const normalizedHeight = Math.min(heightDiff / heightRange, 1.0);
                        const distanceFactor = 1.0 - (dist / shadowCheckRadius);
                        const directionFactor = (dotProduct - 0.3) / 0.7;
                        shadowAmount += normalizedHeight * distanceFactor * directionFactor * 0.2;
                    }
                }
            }
        }
        
        shadowAmount = Math.min(shadowAmount, 1.0);
        
        // –ë–∞–∑–æ–≤–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã—Å–æ—Ç—ã
        const normalizedY = heightRange > 0 ? (p.y - minY) / heightRange : 0.5;
        const baseLight = 0.3 + normalizedY * 0.7;
        
        let shadowFactor = baseLight * (1.0 - shadowAmount * colorSettings.shadowIntensity);
        shadowFactor = Math.max(0.15, Math.min(1.0, shadowFactor));
        
        shadowFactorArr[j] = shadowFactor;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.digit.needsUpdate = true;
    particles.geometry.attributes.shadowFactor.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    controls.update();

    // –ê–Ω–∏–º–∞—Ü–∏—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü - –ø–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
    if (backgroundParticles) {
        const posArr = backgroundParticles.geometry.attributes.position.array;
        const velArr = backgroundParticles.userData.velocity;
        const radArr = backgroundParticles.userData.radius;
        
        for (let i = 0; i < BACKGROUND_PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            posArr[i3] += velArr[i3] * dt * 10;
            posArr[i3 + 1] += velArr[i3 + 1] * dt * 10;
            posArr[i3 + 2] += velArr[i3 + 2] * dt * 10;
            
            // –£–¥–µ—Ä–∂–∏–≤–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Å—Ñ–µ—Ä—ã
            const dist = Math.sqrt(posArr[i3]**2 + posArr[i3+1]**2 + posArr[i3+2]**2);
            const maxDist = radArr[i] * 1.3;
            if (dist > maxDist || dist < radArr[i] * 0.7) {
                const scale = (dist > maxDist ? radArr[i] * 0.7 : maxDist) / dist;
                posArr[i3] *= scale;
                posArr[i3 + 1] *= scale;
                posArr[i3 + 2] *= scale;
            }
        }
        backgroundParticles.geometry.attributes.position.needsUpdate = true;
    }

    renderer.render(scene, camera);
}

init();
animate();
</script>