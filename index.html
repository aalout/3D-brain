<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Morphing Shapes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

<style>
    *, *::before, *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        font-family: "Inter", sans-serif;
        overflow: hidden;
        background: #040307; 
        background-image:
            radial-gradient(circle at 50% 35%, #1d1431 0%, transparent 65%),
            linear-gradient(180deg, #000000 0%, #070012 100%);
        color: #eee;
    }
    #container {
        position: fixed;
        inset: 0;
    }
    .vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 9;
        background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%);
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .instructions {
        position: fixed;
        left: 24px;
        bottom: 24px;
        transform: none;
        padding: 10px 20px;
        font-size: 12px;
        text-align: left;
        pointer-events: none;
        color: #d0b0ff;
        background: rgba(18, 15, 40, 0.25);
        border: 1px solid rgba(122, 70, 255, 0.28);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0,0,0,.45);
    }

</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<div id="container"></div>
<div class="vignette"></div>
<div class="instructions">Drag to explore</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

const PARTICLE_COUNT = 39575;
const BACKGROUND_PARTICLE_COUNT = 5000; // –õ–µ—Ç–∞—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
const DIGIT_SIZE_MULTIPLIER = 1.2; // –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–∞–∑–º–µ—Ä–∞ —Ü–∏—Ñ—Ä

// –ü–æ–≤–æ—Ä–æ—Ç –º–æ–¥–µ–ª–∏ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö)
const MODEL_ROTATION = {
    x: - (Math.PI / 2), // –ü–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ –æ—Å–∏ X (180 –≥—Ä–∞–¥—É—Å–æ–≤)
    y: 0,       // –ü–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Y
    z: Math.PI        // –ü–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Z
};

const colorSettings = {
    color0: new THREE.Vector3(1.0, 1.0, 1.0), // –¶–≤–µ—Ç –¥–ª—è –Ω—É–ª–µ–π (–±–µ–ª—ã–π) RGB 0-1
    color1: new THREE.Vector3(42/255, 241/255, 107/255), // –¶–≤–µ—Ç –¥–ª—è –µ–¥–∏–Ω–∏—Ü rgb(42, 241, 107) RGB 0-1
    bgColor0: new THREE.Vector3(1.0, 1.0, 1.0), // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –Ω—É–ª–µ–π (–±–µ–ª—ã–π) RGB 0-1
    bgColor1: new THREE.Vector3(42/255, 241/255, 107/255), // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü rgb(42, 241, 107) RGB 0-1
    size0: 1.0, // –†–∞–∑–º–µ—Ä –Ω—É–ª–µ–π
    size1: 1.0, // –†–∞–∑–º–µ—Ä –µ–¥–∏–Ω–∏—Ü
    shadowIntensity: 0.95 // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π (0.0 - –Ω–µ—Ç —Ç–µ–Ω–µ–π, 1.0 - –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ —Ç–µ–Ω–∏)
};

let scene, camera, renderer, controls;
let particles, backgroundParticles;
let clock = new THREE.Clock();
let digitTexture0, digitTexture1;

function normalise(points, size) {
    if (points.length === 0) return [];
    const box = new THREE.Box3().setFromPoints(points);
    const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1;
    const centre = box.getCenter(new THREE.Vector3());
    return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim));
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤–µ—Ä—à–∏–Ω –∏ –Ω–æ—Ä–º–∞–ª–µ–π –∏–∑ 3D –º–æ–¥–µ–ª–∏
async function loadModelPattern(modelPath, targetCount) {
    return new Promise((resolve, reject) => {
        const loader = new GLTFLoader();
        loader.load(
            modelPath,
            (gltf) => {
                const points = [];
                const normals = [];
                
                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –≤—Å–µ –º–µ—à–∏ –≤ –º–æ–¥–µ–ª–∏
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        const positionAttribute = geometry.attributes.position;
                        const normalAttribute = geometry.attributes.normal;
                        
                        // –ü–æ–ª—É—á–∞–µ–º –º–∏—Ä–æ–≤—É—é –º–∞—Ç—Ä–∏—Ü—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                        child.updateMatrixWorld();
                        const worldMatrix = child.matrixWorld;
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(worldMatrix);
                        
                        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã –∏ –Ω–æ—Ä–º–∞–ª–∏
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                            vertex.applyMatrix4(worldMatrix);
                            points.push(vertex);
                            
                            if (normalAttribute) {
                                const normal = new THREE.Vector3().fromBufferAttribute(normalAttribute, i);
                                normal.applyMatrix3(normalMatrix).normalize();
                                normals.push(normal);
                            } else {
                                normals.push(new THREE.Vector3(0, 1, 0));
                            }
                        }
                    }
                });
                
                // –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –≤–µ—Ä—à–∏–Ω –≤ –∫–æ–Ω—Å–æ–ª—å
                const uniqueVertexCount = points.length;
                console.log(`üìä –ú–æ–¥–µ–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç ${uniqueVertexCount} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω`);
                console.log(`üéØ –ó–∞–ø—Ä–æ—à–µ–Ω–æ —á–∞—Å—Ç–∏—Ü: ${targetCount}`);
                
                if (uniqueVertexCount < targetCount) {
                    console.warn(`‚ö†Ô∏è PARTICLE_COUNT (${targetCount}) –±–æ–ª—å—à–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–µ—Ä—à–∏–Ω –º–æ–¥–µ–ª–∏ (${uniqueVertexCount}). –ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –¥—É–±–ª–∏–∫–∞—Ç—ã.`);
                    console.log(`üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å PARTICLE_COUNT <= ${uniqueVertexCount} –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è`);
                } else {
                    console.log(`‚úÖ –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–µ—Ä—à–∏–Ω –¥–ª—è ${targetCount} —á–∞—Å—Ç–∏—Ü`);
                }
                
                // –†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –≤–µ—Ä—à–∏–Ω –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã
                const resultPoints = [];
                const resultNormals = [];
                if (points.length === 0) {
                    reject(new Error('–ú–æ–¥–µ–ª—å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ—Ä—à–∏–Ω'));
                    return;
                }
                
                if (points.length >= targetCount) {
                    const step = points.length / targetCount;
                    for (let i = 0; i < targetCount; i++) {
                        const idx = Math.floor(i * step);
                        resultPoints.push(points[idx].clone());
                        resultNormals.push(normals[idx].clone());
                    }
                } else {
                    resultPoints.push(...points.map(p => p.clone()));
                    resultNormals.push(...normals.map(n => n.clone()));
                    
                    while (resultPoints.length < targetCount) {
                        const idx = resultPoints.length % points.length;
                        resultPoints.push(points[idx].clone());
                        resultNormals.push(normals[idx].clone());
                    }
                }
                
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ–∑–∏—Ü–∏–∏
                const normalizedPoints = normalise(resultPoints, 50);
                
                resolve({ points: normalizedPoints, normals: resultNormals });
            },
            undefined,
            (error) => {
                reject(error);
            }
        );
    });
}

function createTextTexture(text, size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size * 0.8}px Inter, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // –ï—Å–ª–∏ —ç—Ç–æ "1", –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤ –∏ –æ—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º
    if (text === '1') {
        ctx.translate(size / 2, size / 2);
        ctx.rotate(Math.PI);
        ctx.scale(-1, 1); // –û—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        ctx.translate(-size / 2, -size / 2);
    }
    
    ctx.fillText(text, size / 2, size / 2);
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

// –ü—Ä–æ—Å—Ç–∞—è —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è —Ü–∏—Ñ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏
function hashPosition(x, y, z) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    const hash = ((x * 73856093) ^ (y * 19349663) ^ (z * 83492791)) >>> 0;
    return hash % 2; // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0 –∏–ª–∏ 1
}

function makeParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const shadowFactor = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
        size[i] = 2.0; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –æ–±—ä–µ–º–∞
        // –¶–∏—Ñ—Ä–∞ –±—É–¥–µ—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏ –≤ applyPattern
        digit[i] = 0.0; // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ
        shadowFactor[i] = 1.0; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∑–∞—Ç–µ–º–Ω–µ–Ω–∏—è (1.0 = –±–µ–∑ —Ç–µ–Ω–∏, 0.0 = –ø–æ–ª–Ω–∞—è —Ç–µ–Ω—å)
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("shadowFactor", new THREE.BufferAttribute(shadowFactor, 1));
    
    const sizeMult = DIGIT_SIZE_MULTIPLIER.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            color0: { value: new THREE.Vector3(1.0, 1.0, 1.0) }, // –¶–≤–µ—Ç –¥–ª—è –Ω—É–ª–µ–π (–±–µ–ª—ã–π)
            color1: { value: new THREE.Vector3(42/255, 241/255, 107/255) }, // –¶–≤–µ—Ç –¥–ª—è –µ–¥–∏–Ω–∏—Ü rgb(42, 241, 107)
            size0: { value: 2.0 }, // –†–∞–∑–º–µ—Ä –Ω—É–ª–µ–π
            size1: { value: 2.0 }, // –†–∞–∑–º–µ—Ä –µ–¥–∏–Ω–∏—Ü
            shadowIntensity: { value: 0.7 } // –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            attribute float shadowFactor;
            uniform float size0;
            uniform float size1;
            varying float vDigit;
            varying float vShadowFactor;
            varying vec3 vPosition;
            void main() {
                vDigit = digit;
                vShadowFactor = shadowFactor;
                vPosition = position;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                float finalSize = vDigit < 0.5 ? size0 : size1;
                gl_PointSize = finalSize * ${sizeMult} * (400.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 color0;
            uniform vec3 color1;
            uniform float shadowIntensity;
            varying float vDigit;
            varying float vShadowFactor;
            varying vec3 vPosition;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–∏—Ñ—Ä—ã
                vec3 baseColor = vDigit < 0.5 ? color0 : color1;
                
                // –¢–µ–Ω–∏ —á–µ—Ä–µ–∑ opacity - –≤ —Ç–µ–Ω—è—Ö —Ü–∏—Ñ—Ä—ã —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –ø—Ä–æ–∑—Ä–∞—á–Ω–µ–µ
                // vShadowFactor: 1.0 = –ø–æ–ª–Ω—ã–π —Å–≤–µ—Ç (–ø–æ–ª–Ω–∞—è opacity), 0.0 = –ø–æ–ª–Ω–∞—è —Ç–µ–Ω—å (–º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è opacity)
                float finalOpacity = texColor.a * vShadowFactor;
                
                gl_FragColor = vec4(baseColor, finalOpacity);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });
    return new THREE.Points(geo, mat);
}

// –°–æ–∑–¥–∞–µ—Ç —Ñ–æ–Ω–æ–≤—ã–µ —á–∞—Å—Ç–∏—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ—Ç–∞—é—Ç –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
function createBackgroundParticles(count) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const size = new Float32Array(count);
    const digit = new Float32Array(count);
    const velocity = new Float32Array(count * 3);
    const radius = new Float32Array(count);
    
    const R = 120; // –†–∞–¥–∏—É—Å —Å—Ñ–µ—Ä—ã –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏

    for (let i = 0; i < count; i++) {
        // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å—Ñ–µ—Ä–µ
        const Œ∏ = Math.random() * 2 * Math.PI;
        const œÜ = Math.acos(2 * Math.random() - 1);
        const r = R + (Math.random() - 0.5) * 40;
        
        pos[i * 3] = r * Math.sin(œÜ) * Math.cos(Œ∏);
        pos[i * 3 + 1] = r * Math.sin(œÜ) * Math.sin(Œ∏);
        pos[i * 3 + 2] = r * Math.cos(œÜ);
        
        // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        velocity[i * 3] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocity[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        
        radius[i] = r;
        size[i] = 1.0 + Math.random() * 0.5;
        digit[i] = Math.random() < 0.5 ? 0.0 : 1.0;
    }
    
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
    geo.setAttribute("digit", new THREE.BufferAttribute(digit, 1));
    geo.setAttribute("velocity", new THREE.BufferAttribute(velocity, 3));
    geo.setAttribute("radius", new THREE.BufferAttribute(radius, 1));
    
    const sizeMult = DIGIT_SIZE_MULTIPLIER.toFixed(1);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            texture0: { value: digitTexture0 },
            texture1: { value: digitTexture1 },
            bgColor0: { value: new THREE.Vector3(1.0, 1.0, 1.0) }, // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –Ω—É–ª–µ–π
            bgColor1: { value: new THREE.Vector3(42/255, 241/255, 107/255) } // –¶–≤–µ—Ç –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü
        },
        vertexShader: `
            attribute float size;
            attribute float digit;
            varying float vDigit;
            void main() {
                vDigit = digit;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * ${sizeMult} * (300.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }`,
        fragmentShader: `
            uniform sampler2D texture0;
            uniform sampler2D texture1;
            uniform vec3 bgColor0;
            uniform vec3 bgColor1;
            varying float vDigit;
            void main() {
                vec2 uv = gl_PointCoord;
                vec4 texColor = vDigit < 0.5 ? texture2D(texture0, uv) : texture2D(texture1, uv);
                if (texColor.a < 0.01) discard;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–∏—Ñ—Ä—ã
                vec3 baseColor = vDigit < 0.5 ? bgColor0 : bgColor1;
                
                gl_FragColor = vec4(baseColor, texColor.a * 0.7);
            }`,
        transparent: true,
        depthWrite: true,
        blending: THREE.NormalBlending
    });

    const points = new THREE.Points(geo, mat);
    points.userData.velocity = velocity;
    points.userData.radius = radius;
    return points;
}


function init() {
    digitTexture0 = createTextTexture('0', 256);
    digitTexture1 = createTextTexture('1', 256);
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050203, .012);

    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 2500);
    camera.position.set(0, 0, 80);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("container").appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 20;
    controls.maxDistance = 200;
    controls.target.set(0, 0, 0);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    particles = makeParticles(PARTICLE_COUNT);
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ü–≤–µ—Ç–æ–≤, —Ä–∞–∑–º–µ—Ä–æ–≤ –∏ —Ç–µ–Ω–µ–π
    particles.material.uniforms.color0.value = colorSettings.color0;
    particles.material.uniforms.color1.value = colorSettings.color1;
    particles.material.uniforms.size0.value = colorSettings.size0;
    particles.material.uniforms.size1.value = colorSettings.size1;
    particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
    
    scene.add(particles);
    
    // –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –ª–µ—Ç–∞—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    backgroundParticles = createBackgroundParticles(BACKGROUND_PARTICLE_COUNT);
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
    backgroundParticles.material.uniforms.bgColor0.value = colorSettings.bgColor0;
    backgroundParticles.material.uniforms.bgColor1.value = colorSettings.bgColor1;
    scene.add(backgroundParticles);
    
    // –î–µ–ª–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    window.updateColors = () => {
        particles.material.uniforms.color0.value.copy(colorSettings.color0);
        particles.material.uniforms.color1.value.copy(colorSettings.color1);
        particles.material.uniforms.size0.value = colorSettings.size0;
        particles.material.uniforms.size1.value = colorSettings.size1;
        particles.material.uniforms.shadowIntensity.value = colorSettings.shadowIntensity;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü
        if (backgroundParticles) {
            backgroundParticles.material.uniforms.bgColor0.value.copy(colorSettings.bgColor0);
            backgroundParticles.material.uniforms.bgColor1.value.copy(colorSettings.bgColor1);
        }
    };
    window.colorSettings = colorSettings;

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å –º–æ–∑–≥–∞
    loadModelPattern('assets/brain6/scene.gltf', PARTICLE_COUNT)
        .then((data) => {
            applyPattern(data.points, data.normals);
        })
        .catch((error) => {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
        });

    addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
}

// –ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ç–æ—á–∫–∏ –º–æ–¥–µ–ª–∏ –∫ —á–∞—Å—Ç–∏—Ü–∞–º
// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ—Ä–º–∞–ª–∏ –∏–∑ –º–æ–¥–µ–ª–∏ –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è –∏–∑–≤–∏–ª–∏–Ω
function applyPattern(pts, normals){
    if (!pts || pts.length === 0) return;
    const particleArr = particles.geometry.attributes.position.array;
    const digitArr = particles.geometry.attributes.digit.array;
    const shadowFactorArr = particles.geometry.attributes.shadowFactor.array;
    
    // –°–æ–∑–¥–∞–µ–º –º–∞—Ç—Ä–∏—Ü—ã –ø–æ–≤–æ—Ä–æ—Ç–∞
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationFromEuler(new THREE.Euler(MODEL_ROTATION.x, MODEL_ROTATION.y, MODEL_ROTATION.z, 'XYZ'));
    const normalRotationMatrix = new THREE.Matrix3().getNormalMatrix(rotationMatrix);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –∫ —Ç–æ—á–∫–∞–º –∏ –Ω–æ—Ä–º–∞–ª—è–º
    const rotatedPts = [];
    const rotatedNormals = [];
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const n = normals[i];
        if (!p) {
            rotatedPts.push(null);
            rotatedNormals.push(null);
            continue;
        }
        rotatedPts.push(p.clone().applyMatrix4(rotationMatrix));
        rotatedNormals.push(n ? n.clone().applyMatrix3(normalRotationMatrix).normalize() : new THREE.Vector3(0, 1, 0));
    }
    
    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ (—Å–≤–µ—Ä—Ö—É-—Å–ø–µ—Ä–µ–¥–∏-—Å–ª–µ–≤–∞)
    const lightDir = new THREE.Vector3(0.3, 1.0, 0.5).normalize();
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Ç–æ—á–∫–∏
    for (let j = 0; j < PARTICLE_COUNT; j++) {
        const idx = j * 3;
        const p = rotatedPts[j];
        const n = rotatedNormals[j];
        if (!p) continue;
        
        particleArr[idx] = p.x;
        particleArr[idx + 1] = p.y;
        particleArr[idx + 2] = p.z;
        
        digitArr[j] = hashPosition(p.x, p.y, p.z);
        
        // –û—Å–≤–µ—â–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ—Ä–º–∞–ª–µ–π (Lambertian)
        // dot(normal, lightDir) –¥–∞—ë—Ç –æ—Å–≤–µ—â—ë–Ω–Ω–æ—Å—Ç—å: 1 = –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Å–≤–µ—â–µ–Ω–æ, -1 = –≤ —Ç–µ–Ω–∏
        const NdotL = n.dot(lightDir);
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –¥–∏–∞–ø–∞–∑–æ–Ω [0, 1] —Å –º—è–≥–∫–∏–º –ø–µ—Ä–µ—Ö–æ–¥–æ–º
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º half-lambert –¥–ª—è –±–æ–ª–µ–µ –º—è–≥–∫–∏—Ö —Ç–µ–Ω–µ–π
        const halfLambert = NdotL * 0.5 + 0.5;
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ç–µ–Ω–µ–π
        // shadowIntensity –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç –∫–æ–Ω—Ç—Ä–∞—Å—Ç –º–µ–∂–¥—É —Å–≤–µ—Ç–æ–º –∏ —Ç–µ–Ω—å—é
        const ambient = 1.0 - colorSettings.shadowIntensity;
        let shadowFactor = ambient + halfLambert * colorSettings.shadowIntensity;
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω
        shadowFactor = Math.max(0.05, Math.min(1.0, shadowFactor));
        
        shadowFactorArr[j] = shadowFactor;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.digit.needsUpdate = true;
    particles.geometry.attributes.shadowFactor.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    controls.update();

    // –ê–Ω–∏–º–∞—Ü–∏—è —Ñ–æ–Ω–æ–≤—ã—Ö —á–∞—Å—Ç–∏—Ü - –ø–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –º–æ–¥–µ–ª–∏
    if (backgroundParticles) {
        const posArr = backgroundParticles.geometry.attributes.position.array;
        const velArr = backgroundParticles.userData.velocity;
        const radArr = backgroundParticles.userData.radius;
        
        for (let i = 0; i < BACKGROUND_PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            posArr[i3] += velArr[i3] * dt * 10;
            posArr[i3 + 1] += velArr[i3 + 1] * dt * 10;
            posArr[i3 + 2] += velArr[i3 + 2] * dt * 10;
            
            // –£–¥–µ—Ä–∂–∏–≤–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Å—Ñ–µ—Ä—ã
            const dist = Math.sqrt(posArr[i3]**2 + posArr[i3+1]**2 + posArr[i3+2]**2);
            const maxDist = radArr[i] * 1.3;
            if (dist > maxDist || dist < radArr[i] * 0.7) {
                const scale = (dist > maxDist ? radArr[i] * 0.7 : maxDist) / dist;
                posArr[i3] *= scale;
                posArr[i3 + 1] *= scale;
                posArr[i3 + 2] *= scale;
            }
        }
        backgroundParticles.geometry.attributes.position.needsUpdate = true;
    }

    renderer.render(scene, camera);
}

init();
animate();
</script>